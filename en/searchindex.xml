<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Centralized exchanges and wallets should take the lead in using Account abstraction</title><url>https://www.tiege.dev/en/post/centrals-instructions-should-using-account-abstraction/</url><categories><category>web3</category><category>crypto</category></categories><tags><tag>web3</tag><tag>account abstraction</tag><tag>crypto</tag><tag>Etheruem</tag></tags><content type="html"> Centralized exchanges and wallets should take the lead in using Account abstraction
Currently, when centralized exchanges and wallets process user tokens, the usual practices are as follows:
Assign an address to each user; When the user transfers currency to a changed address, transfer a small amount of main chain tokens (ETH, BNB, TRX, etc) to the changed address. Transfer the user token to the fund collection address of the exchange or wallet This approach has some disadvantages:
The operation is complicated The private key of each address needs to be strictly managed. Fund collection requires a main chain token to be transferred to each address first as gas fee, and then funds can be collected. Each address collection requires a transaction, and transactions cannot be merged. Therefore, centralized exchanges and wallets can consider using Account Abstraction accounts as user addresses. This approach has several advantages:
Convenient collection. a. When creating an account, use the approve method to transfer the token transfer permission of the address to the collection address; b. You can transfer funds from multiple accounts in one transaction through contract methods, improving efficiency and saving gas at the same time; The main disadvantage of this method is that when creating an AA account for the first time, a gas fee is required.</content></entry><entry><title>Make JWT more safe</title><url>https://www.tiege.dev/en/post/make-jwt-more-safe/</url><categories><category>JWT</category></categories><tags><tag>JWT</tag><tag>safety</tag></tags><content type="html"> What is JWT JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.
Make JWT more safe secret for every Account In some best practice of JWT, they just say we need an universe secret for every account signature, which mostly from an envirment varible. But the secret is so fundemental, is it enough safe that a global secret for all account? Nobody care it, nobody discuss it, nobody mention it.
We use different salt to hash account password for different account, why we use same secret for all account? The JWT is JUST as important as user&rsquo;s password!
In my opinion, we should use different secret for every account, just like password salt.
If we use different secret for every account, we should save the secret in server side, DB or redis. Of course, this will slow down the JWT validate flow, but we could save the secret in server&rsquo;s memory cache after server start up.
save &amp; validate signature in server side JWT is mostly about how to verify the JWT token is valid, by the signature. In most scene, this is great. But in some case, for example, we want kick off a special user, JWT can do nothing.
So, we could save the JWT signature in the server, then we could verify the JWT twice:
first, verify the signature; second, check the signature in server DB or redis, if exists, the JWT is valid; or else invalid By this method, we can kick off user or force user re-login.
Also, there are some tricks, we don&rsquo;t need to save all JWT payload in the server, for example, we can just save the userId and JWT signature in the server side.
JWT for anonymous or visitors Sometime we want give better user expirence for the anonymous or visitors, we can use JWT to record visitor&rsquo;s information. For example, the user&rsquo;s information:
name IP address first visit time location(optional) use these information, we could track visitors and provide good expirence.
Question If we use JWT this way, why we use JWT instead of session? One of the most benefit of JWT is the client can get many information from JWT, even they have not connect to the server.</content></entry><entry><title>rate fee of loopback swap in uniswap</title><url>https://www.tiege.dev/en/post/uniswap/uniswap-loopback-swap-fee/</url><categories><category>Defi</category><category>uniswap</category></categories><tags><tag>uniswap</tag><tag>uniswap v2</tag><tag>Defi</tag><tag>Solidity</tag><tag>arbitrage</tag></tags><content type="html"> The transaction fee of uniswap is derived from the identity of x * y = K. In a specific transaction scenario, such as a loopback transaction, our transaction cost can be far lower than the rated fee.
What is a loopback transaction The loopback transaction is a transaction in a transaction pair tokenA/tokenB, first exchange tokenA to get tokenB, and then immediately exchange the obtained tokenB back to tokenA.
The standard rate of uniswap v2 is 0.3%, then the cost of loopback transaction is 0.6%, this cost is quite high. If we are just to brush the transaction volume, we need an effective way to reduce Handling fees, loopback transactions are a very effective way.
Theoretical Derivation The following is our detailed derivation process. Assumptions are as follows:
dx: the number of tokenA entered r0: the reserve quantity of tokenA r1: The reserve quantity of tokenB dy: the amount of the first tokenA -> tokenB swap ex: the second swap tokenB -> the number of tokenA According to the formula of uniswap, the calculation is as follows:
dy = dx*997*r1/(1000*r0 + dx*997) R1 = r1-dy R0 = r0 + dx ex = dy*997*R0/(1000*R1 + dy*997) Substituting dy, after simplification, we can get:
ex = 997*997*dx*(r0+dx) / (1000*1000*r0 + 997*997*dx) Divide by dx at the same time:
ex/dx = 997*997*(r0+dx) / (1000*1000*r0 + 997*997*dx) Since ex is our tokenA quantity at the end of the final loopback transaction, dx is our tokenA input quantity, and 1-ex/dx is our handling fee ratio.
It can be seen from the above formula that the final loopback transaction ex is only related to the input dx and the reserve of tokenA, and the higher the ratio of the input number dx to tokenA reserve, the final result is The closer the ex/dx is to 1, the less the fee is paid.
Code calculation The test code is as following:
Filename: loopbackSwap.js
const BigNumber = require('ethers').BigNumber const e18 = BigNumber.from('1000000000000000000') const getAmountOut = (amountIn, r0, r1) => { const amountInWithFee = amountIn.mul(997) , numerator = amountInWithFee.mul(r1) , denominator = r0.mul(1000).add(amountInWithFee); return numerator.div(denominator) } const getAmountBack = (amtIn, r0, r1, printable = false) => { const out = getAmountOut(amtIn, r0, r1) r0 = r0.add(amtIn) r1 = r1.sub(out) const dx = getAmountOut(out, r1, r0) if (printable) { console.info('swap x->y: out=%s r0=%s r1=%s backx=%s', out.toString(), r0.toString(), r1.toString(), dx.toString()) } return {amtInter: out, amtOut: dx} } function loopbackSwap() { const reserveA = BigNumber.from(1000000).mul(e18) , reserveB = BigNumber.from(2000000).mul(e18) , ratio = (multor) => reserveA.mul(multor).div(1000) let amts = [ 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 3000, 5000, 10000] for (let amt of amts) { let amtIn = ratio(amt) let {amtOut} = getAmountBack(amtIn, reserveA, reserveB) console.info('dx/reserve=%s amtOut/amtIn=%s', amt/1000, amtOut.mul(10000).div(amtIn).toNumber()/10000) } } loopbackSwap() run the scripts:
npx hardhat run loopbackSwap.js dx/reserve=0.001 amtOut/amtIn=0.994 dx/reserve=0.002 amtOut/amtIn=0.994 dx/reserve=0.005 amtOut/amtIn=0.994 dx/reserve=0.01 amtOut/amtIn=0.994 dx/reserve=0.02 amtOut/amtIn=0.9941 dx/reserve=0.05 amtOut/amtIn=0.9942 dx/reserve=0.1 amtOut/amtIn=0.9945 dx/reserve=0.2 amtOut/amtIn=0.995 dx/reserve=0.5 amtOut/amtIn=0.9959 dx/reserve=1 amtOut/amtIn=0.9969 dx/reserve=2 amtOut/amtIn=0.9979 dx/reserve=3 amtOut/amtIn=0.9984 dx/reserve=5 amtOut/amtIn=0.9989 dx/reserve=10 amtOut/amtIn=0.9994 It can be seen from the results that when dx/reserve exceeds 1, the handling fee rate drops rapidly, and when dx/reserve=10, the handling fee is only 6/10000.
As a result, lightning loans can be used to lend a large amount of funds from the borrowing pool at a lower interest rate, and then perform loopback transactions. In some exchanges where transactions are mining, mining can be reduced in this way Handling fee, arbitrage profit.
Action Now, We can write a contract to execute our loopback transaction.
It should be noted that we cannot directly set the path parameter of uniswap router to [tokenA, tokenB, tokenA] for loopback transactions, but must be divided into two swaps, the first is [tokenA, tokenB] , then [tokenB, tokenA].
The sample code is as following:
/// @dev swapLoopback swap tokenA to tokenB, then swap tokenB to tokenA /// @param _router uniswap-like router /// @param reward the reward token /// @param amountIn amount in /// @param amountOutMin just set to 0 /// @param path [tokenA, tokenB] function swapLoopback( address _router, // router address reward, // reward token uint amountIn, uint amountOutMin, address[] memory path ) public onlyOwner { address tokenIn = path[0]; uint tokenInitial = IERC20(tokenIn).balanceOf(address(this)); _approve(IERC20(tokenIn), address(_router)); // solhint-disable-next-line uint256 ts = block.timestamp + 60; uint[] memory amounts = IUniswapRouter(_router).swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), ts); path[0] = path[1]; path[1] = tokenIn; // console.log("amounts:", amounts[1]); _approve(IERC20(path[0]), address(_router)); amounts = IUniswapRouter(_router).swapExactTokensForTokens(amounts[1], amountOutMin, path, address(this), ts); // other arbitrage code with reward.. reward; }</content></entry><entry><title>About</title><url>https://www.tiege.dev/en/about/</url><categories/><tags/><content type="html"> 铁叔 老年程序员，以代码为生计，正在为世界的去中心化事业而奋斗。
Older programmers, who coding for a living, and fighting for a decentralize world.
projects technology Rust golang C/C++ smart contract &amp; solidity java/Spring frontend contract me Email: guotie.9#gmail.com</content></entry><entry><title>libuv与TCP Keepalive</title><url>https://www.tiege.dev/en/post/libuv-and-tcp-keepalive/</url><categories><category>c/c++</category></categories><tags><tag>libuv</tag><tag>tcp</tag><tag>TCP Keepalive</tag><tag>linux</tag></tags><content type="html"> libuv 与 TCP Keepalive 关于 keepalive 这里的keepalive与HTTP的keepalive不同，这里的keepalive是TCP层的keepalive，用处是当两台机器之间通信时，中间网络出现故障，这时，两端并无法感知网络故障这个事件，无法及时发现网络故障。
HTTP的keepalive是指，一个请求在请求头部增加一个keep alive的行，这时，服务端传输完成后，不会关闭这个TCP连接，还可以继续下次HTTP请求，提高了效率。
Linux内核关于TCP keepalive的说明在这里： http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html
其中：
tcp_keepalive_time the interval between the last data packet sent (simple ACKs are not considered data) and the first keepalive probe; after the connection is marked to need keepalive, this counter is not used any further tcp_keepalive_intvl the interval between subsequential keepalive probes, regardless of what the connection has exchanged in the meantime tcp_keepalive_probes the number of unacknowledged probes to send before considering the connection dead and notifying the application layer 大致翻译一下就是
tcp_keepalive_time 当一台机器在 N 秒内，还没有收到对方的任何数据时，开始 keepalive 探测对方是否正常 tcp_keepalive_intvl keepalive报文发送的间隔，单位秒 tcp_keepalive_probes keepalive报文探测次数 也就是说，在 tcp_keepalive_time 秒内仍未收到对端数据时，开始发起 keepalive 探测，每隔 tcp_keepalive_intvl 发送一个探测报文，当 发送 tcp_keepalive_probes 探测报文，对方仍未响应时，关闭连接。
在Linux下，可以通过以下方式查看系统的keepalive配置：
[root@localhost ~]# cat /proc/sys/net/ipv4/ 1800 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_probes 9 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_intvl 75 keepalive 接口 设置一个套接字的keepalive的方法如下：
1. enable keepalive int on = 1; if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) { // log return -1; } 2. 设置 tcp_keepalive_time int idle = 10; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(int)) &lt; 0) { // log return -1; } 3. 设置 tcp_keepalive_probes int probes = 4; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;probes, sizeof(int)) &lt; 0) { // log return -1; } 4. 设置 tcp_keepalive_intvl int intvl = 1; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;intvl, sizeof(int)) &lt; 0) { // log return -1; } libuv 的 keepalive libuv提供的接口只能设置上面的两个：
enable keepalive 设置 tcp_keepalive_time libuv提供的接口为 uv_tcp_keepalive, 函数原型如下：
int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) Enable / disable TCP keep-alive. delay is the initial delay in seconds, ignored when enable is zero. 该函数的实现代码如下：
int uv__tcp_keepalive(int fd, int on, unsigned int delay) { if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) return -errno; #ifdef TCP_KEEPIDLE if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;delay, sizeof(delay))) return -errno; #endif /* Solaris/SmartOS, if you don't support keep-alive, * then don't advertise it in your system headers... */ /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ #if defined(TCP_KEEPALIVE) &amp;&amp; !defined(__sun) if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &amp;delay, sizeof(delay))) return -errno; #endif return 0; } int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) { int err; if (uv__stream_fd(handle) != -1) { err =uv__tcp_keepalive(uv__stream_fd(handle), on, delay); if (err) return err; } if (on) handle->flags |= UV_TCP_KEEPALIVE; else handle->flags &amp;= ~UV_TCP_KEEPALIVE; /* TODO Store delay if uv__stream_fd(handle) == -1 but don't want to enlarge * uv_tcp_t with an int that's almost never used... */ return 0; } 从上面的代码可以看出，当 uv__stream_fd(handle) 不成功时，仅仅设置该连接的flags位，实际上并没有用到delay这个参数。也就是说，只有当连接已经成功建立时，才能设置 tcp_keepalive_time，如果连接还没有建立成功，则这个值根本没有设置。
如果要设置后面两个数值的话，需要自己实现, 示例代码如下：
// // 设置 keepalive 相关的2个参数 // probes: 对应内核 tcp_keepalive_probes, 发送多少次keepalive报文还未收到回应时, close该连接 // intvl: 对应内核 tcp_keepalive_intvl, 发送keepalive报文的间隔时间 // idle: 对应内核 tcp_keepalive_time int set_keep_alive(const uv_handle_t* handle, int probes, int intvl, int idle) { int ret; uv_os_fd_t fd; ret = uv_fileno(handle, &amp;fd); if (ret &lt; 0) { return ret; } if (idle > 0) { if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(idle))) return -1; } // 设置 tcp_keepalive_intvl if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (const void *) &amp;intvl, sizeof(int)) &lt; 0 ) { return -1; } // 设置 tcp_keepalive_probes if ( setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (const void *) &amp;probes, sizeof(int)) &lt; 0) { return -1; } return 0; } 这个函数只能在连接建立成功后调用，因为只有连接建立成功才有fd，即uv_fileno才会返回成功。</content></entry></search>