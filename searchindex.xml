<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>关于稳定币的一个小小的想法(1)</title><url>https://www.tiege.dev/post/thinking/permissionless-lending/</url><categories><category>Defi</category><category>Solidity</category><category>lending</category><category>algo-stablecoin</category></categories><tags><tag>defi</tag><tag>lending</tag><tag>stablecoin</tag></tags><content type="html"> 自从2019年covid-19疫情以来，出现了各种去全球化思潮和管制; 在乌克兰战争之后, 金融领域的去全球化反思开始出现，美元还能信任吗？中立国家的金融机构还能信任吗？而这些信任危机的背后，正说明去中心化的BTC, ETH将是未来人类发展的正确方向。
我们正处于一场伟大变革的十字路口。
关于权力 谈论稳定币之前，我们需要先讨论一下权力。
目前对crypto的各种监管都是假象，本质是权力之争。权力的特点，决定了权力永远在自我强化，自我膨胀。现在的权力绝大部分掌握在政客和富豪手中；因此，我们可以看到，各个政府的权力都在不断的扩大，同时，财富也越来越集中，各个国家的富豪的财富占比都在不断上升。
随着区块链对金融、经济的渗透，一部分权力将不可避免的转移到链上，转移到代码上，这是目前的权力所有者无法忍受的，他们必然会想尽一切办法，尽可能阻止这种权力的转移。
让我们来看看这次乌克兰战争的实例。自从乌克兰战争以来，各种机构都被美国要求制裁俄罗斯的实体，个人。各大crypto交易所也不例外，最明显的是binance。多名美国政客点名cex，binance，要求他们更加主动的对俄罗斯的实体、个人实行制裁。binance CEO cz说，与欧洲几百家银行相比，binance上管理的俄罗斯用户的资产不足银行的0.3%，但美国的政客却一直盯着binance，要求binance制裁俄罗斯用户。难道binance的影响力超过那几百家银行吗？显然不是。
有两点原因。 第一，cex是对金融领域的颠覆。一直以来，金融领域都是持牌照经营，从而保证了从业者的垄断地位和收益，而cex从某种程度上打破了这一垄断，自然一直是监管者的眼中钉；binance作为规模最大的cex，自然首当其冲。
第二，cex的资产可以方便的转移到链上，导致无法被制裁；而银行的资产，只能在各个银行之间转移，无论转到那家银行，都无法避免被制裁；
区块链挑战的是国家的金融体系、铸币权，因此，无论是中国，还是美国，还是其他政府，都不愿意看到区块链的发展壮大。中国经过几轮打击，基本消灭了境内的交易所和挖矿产业；同期, 尽管facebook做了很多解释，做了很多准备，并且拉上了很多传统金融机构，但美国还是毫不犹豫的阻止了facebook发行稳定币的想法；俄罗斯在乌克兰战争前一直限制BTC的使用，只允许挖BTC赚外汇。
如果各国政府是铁板一块，估计早已通过法律禁止了BTC，ETH的使用。然而，这个世界的各个国家都有利益冲突，不同的国家有不同的诉求，这就给了区块链行业的发展机会。
美国，作为全球霸主，可以通过货币发行收割全世界；其他大国，政府可以通过发行法币，收割本国；最惨的是一些小国，基本没有货币自主权，只能被收割，所以，我们看到，萨尔加多最先使用BTC作为国家储备货币，然后南美各国也纷纷跟进，研究这一政策。现在俄罗斯在被各种制裁，踢出swift体系的情况下，对BTC的态度已经有了180度的转变，甚至已经愿意接受BTC支付购买原油，天然气。
混乱的世界促进了crypto的发展。乌克兰一开始就接受crypto捐赠，并且还发行了NFT，现在俄罗斯在讨论接受BTC支付购买原油、天然气，这些政府行为，都极大的增强了crypto的共识。这对于目前的全球以美元为基础的货币体系提出了挑战，由于crypto无需信任，无法被任何人，任何组织，任何国家控制，超越国家主权，因此必然会取得最终的胜利。
政府在发行法币的过程中，得到的隐形收益被称为铸币税。在区块链对政府的各种挑战中，铸币权的挑战是最大的。BTC，ETH更多的是资产属性，而稳定币，影响力将涉及到支付，流通，清算，深入到经济、金融的各个环节中。给政府带来了巨大的收益，任何政府都不会轻易放弃这一权力，这是权力的本质决定的。因此，我们可以看到，近两年美国尤其加强了对稳定币的监管。
下图是1990年到2020年美国政府的负债走势图。在全球200多个国家中，美国是比较克制的政府，但是尽管如此，美国政府的负债还是在加速上升，可想而知，其他国家的人民被通货膨胀掠夺了多少财富。 ![]
paypal是一家伟大的公司。自1998年以来，paypal从一个几个人的团队，打败了无数竞争对手，成为现在的巨无霸，并且深刻的改变了支付行业; 尽管如此，paypal并没能完全实现自己最初的愿景 ———— 让世界上大多数国家的人民免受通胀之苦。如今，在货币不断超发的情况下，连美国人都已经开始饱受通胀之苦。
100年前，我们吃的食物，住的房子都比现在便宜很多，当然我们的收入也比现在少很多。在政府不断发行法币的过程中，由于货币流动的时效性，每个人获得的收益不同，政府获得了铸币税的额外收益；同时，有少部分先知先觉通过种种手段，获得更多的收益，而大部分人都是通货膨胀的受害者，在货币超发的过程中，变得越来越贫穷。
这并不是paypal不够优秀，不够伟大；而是从本质上说，paypal无法做到这一点；同时，任何个人，任何组织，任何政府都无法做到。铸币税是通胀的根源。权力的腐化，人性的贪婪是无法改变的，面临铸币税的巨大诱惑，权力无法永远克制自己，货币一定会不断的超发，因此，世界上任何信用货币的最终结局都是崩溃，从古至今，无一例外。
OK，我们即将进入稳定币的正题。如果要阻止通货膨胀对普罗大众的剥削，就必须使用去中心化的算法稳定币。</content></entry><entry><title>BUSL开源许可协议</title><url>https://www.tiege.dev/post/busl-opensource-license/</url><categories><category>Defi</category><category>License</category></categories><tags><tag>BUSL</tag><tag>opensource</tag><tag>license</tag><tag>uniswap</tag><tag>aave</tag></tags><content type="html"> 去年，uniswap v3 也更改了开源协议，使用了BUSL协议。无独有偶，最近发布的AAVE v3页更改了开源协议，新的开源协议也是BUSL协议。
让我们来看看什么是BUSL协议。
BUSL BUSL是 MariaDB 提出的一个许可协议. uniswap v3 的许可参数如下：
----------------------------------------------------------------------------- Parameters Licensor: Uniswap Labs Licensed Work: Uniswap V3 Core The Licensed Work is (c) 2021 Uniswap Labs Additional Use Grant: Any uses listed and defined at v3-core-license-grants.uniswap.eth Change Date: The earlier of 2023-04-01 or a date specified at v3-core-license-date.uniswap.eth Change License: GNU General Public License v2.0 or later ----------------------------------------------------------------------------- 可以看出，最重要的是 Change Date 和 Change License. 就本例而言，它指定了在 2023-04-01 之后, 将该协议变更为GPL协议.
许可条款 用google 翻译如下：
条款 许可方特此授予您复制、修改、创建衍生产品的权利 对许可作品进行工作、重新分发和非生产使用。这 许可方可以在允许有限的情况下作出上述附加使用许可 生产使用。 自变更日或首次公开四周年起生效 根据本协议可分发特定版本的许可作品 许可，以先到者为准，许可方特此授予您以下权利 变更许可的条款，以及段落中授予的权利 以上终止。 如果您对许可作品的使用不符合要求 如本许可证所述，当前有效，您必须购买 来自许可方、其关联实体或授权的商业许可 经销商，或者您必须避免使用许可作品。 原始和修改后的许可作品以及衍生作品的所有副本 许可作品的所有内容均受本许可约束。本许可证适用 对许可作品的每个版本单独进行，更改日期可能会有所不同 许可方发布的许可作品的每个版本。 您必须在每个原件或修改后的副本上显着地展示本许可 的许可作品。如果您收到原始许可作品或 从第三方修改的形式，本条款和条件中规定 许可适用于您对该作品的使用。 任何违反本许可对许可作品的使用将自动 终止您在本许可下的当前和所有其他权利 许可作品的版本。 本许可不授予您任何商标或徽标的任何权利 许可方或其关联公司（前提是您可以使用 本许可明确要求的许可方）。 在适用法律允许的范围内，许可作品提供于 一个“原样”的基础。许可方特此否认所有保证和条件， 明示或暗示，包括（但不限于）对 适销性、特定用途的适用性、非侵权性和 标题。 MariaDB 特此授予您使用本许可证文本许可的权限 您的作品，并使用“商业来源许可证”商标引用它， 只要您遵守下面的许可方公约。 -------------------------------------------------- -------------------------- 许可人契约 考虑到使用本许可证文本的权利和“商业 源许可证”名称和商标，MariaDB 和所有人的许可人契约 许可方提供的许可作品的其他接受者： 1. 要将 GPL 版本 2.0 或任何更高版本指定为变更许可， 或与 GPL 版本 2.0 或更高版本兼容的许可证， 其中“兼容”是指根据变更许可提供的软件可以 包含在 GPL 版本 2.0 下提供的软件程序中或 以后的版本。许可方可以指定额外的变更许可，而无需 局限性。 2. 或者： (a) 指定额外的使用权授予 对本许可证授予的权利施加任何额外限制，如 额外使用补助金；或 (b) 插入文字“无”。 3. 指定更改日期。 4. 不得以任何其他方式修改本许可证。 参考 uniswap v3的协议: https://github.com/Uniswap/v3-core/blob/main/LICENSE</content></entry><entry><title>AAVE v3 主要功能</title><url>https://www.tiege.dev/post/aave/aave-v3-features/</url><categories><category>defi</category><category>aave</category><category>lending</category></categories><tags><tag>aave</tag><tag>defi</tag><tag>lending</tag></tags><content type="html"> AAVE v3的代码已经经过审计，即将发布。这个版本主要集中于几个方面：
资金效率 风险控制策略 去中心化 跨链 AAVE v3合约已经开源，合约地址是：
https://github.com/aave/aave-v3-core
下面我们来看看这个版本带来了哪些具体改进。
功能 相对于AAVE V2，V3的主要功能如下:
Portal 高效模式 eMode 隔离模式 改进风险管理 L2 特色功能 社区贡献 基于社区反馈的技术进步 尽管 Aave 协议在过去两年中运行有效并取得了巨大的增长，社区的贡献为AAVE的技术进步提供了非常关键的作用：
资本效率：V2 不允许用户在收益产生（协议内和/或跨协议部署在各种网络上）或借贷能力方面优化他们提供给 Aave 协议的资产。V3 解决了这个问题。
风险控制调整：虽然 Aave 协议目前具有可以通过 Aave 治理由社区激活的风险控制功能，例如调整借贷能力和维持保证金，但附加功能可以提高 Aave 协议智能合约固有的众所周知的安全性。V3 解决了这个问题。
去中心化： Aave治理稳健且蓬勃发展——通过社区成员提交提案和创建子 DAO（GrantsDAO 和 RiskDAO）。但为了最大限度地去中心化，某些技术特性将允许 Aave 治理通过委托给团队或其他个人来进一步去中心化其功能。
跨链：通过社区的努力，Aave 协议已部署在许多网络中，每个网络都有对应的流动性。但是用户无法将自己的个人流动性从一个网络上无缝转移到另一个网络。V3 解决了这个问题。
V3 的设计旨在创建下一代第 0 层 DeFi 协议，该协议可以显着改善用户体验，同时提供更高的资本效率、更高程度的去中心化和进一步增强的安全性。
Portal Portal示意图：
portal模式可以让用户在多个网络之间无缝转移资产。例如，用户可以在ETH上burn aToken，然后在polygon上mint出来。类似于其他的跨链，不清楚技术原理
高效模式 eMode eMode 示意图:
简单举个例子就是，在eMode下，你质押wBTC，只能借出renBTC，这时，你的质押率可以达到97%，清算线为98%, 然后清算罚金率为2%。也就是在同类资产借贷时，提高了资金利用率，同时降低了风险。
原理是把资产归类(category)，最多可以有255个类别。
例如第一类为稳定币，这个category有USDT，USDC，DAI, 用户甲在这个模式下借贷时，例如存USDC，借DAI，可以有97%的LTV，而普通模式只有75%，这样用户甲的资金利用率就提高了22%
当然，用户依然可以使用非category 1的资产作为抵押，但非category 1的资产的LTV就只能适用普通模式的LTV
新的风险管理参数 隔离模式 隔离模式的目标是允许 Aave 治理协议上新币时，降低风险
当社区成员提交治理提案以在 Aave市场上创建新资产时，该提案将该资产列为“隔离抵押品”，存入这些“隔离”资产的用户只能借出 Aave 治理指定的稳定币，且借款额不能高于指定的债务上限。
当用户提供“隔离资产”作为抵押品时，该用户只能将该资产用作抵押品；即使用户向协议提供其他资产，用户也只能从这些资产上赚取利息，而不能将这些资产用作抵押品。
bug悬赏及riskDao riskDao: https://governance.aave.com/t/proposal-aave-risk-dao/4729
其他特性 涉及代币转移（例如，供应、偿还）的功能支持 EIP 2612 许可（对于 L2 部署很重要）；
支持 EIP 712 签名；
用户可以使用aTokens代替原来借入的标的资产来偿还借入的头寸；
Aave Governance 可以“允许”实体访问即时流动性；???（Aave Governance can “permitlist” entities to access instant liquidity;）
Aave 治理可以重新配置向 Aave DAO 财政部提供的清算或即时流动性交易的任何费用；
新的 flashloanSimple 可减少高达 20% 的gas消耗（标准的全功能函数仍然可用）；
价格预言机逻辑可以提供对基础资产的通用计算（即不再仅限于 ETH）；
新的利率策略优化了稳定的利率计算（并且无需贷款利率预言机）；
代码重组以更加模块化；与 V2 单一存储库相比，V3 代码将分为三个不同的存储库——V3 core, V3 periphery, V3 deployments。这有助于社区贡献和在不同网络上的部署；
智能合约重构以减少代码大小（为未来的其他更改提供更多余量）→ 最多 100K 优化器运行！
有了所有这些新功能，所有功能的 gas 成本仍然全面下降了 10-15% 左右！
代码方面 注: 这部分是我粗略浏览一遍v3后的感受。
gas 费优化 solidity的版本升级为0.8.10，核心几个的Math都已经重写，大部分使用了assembly来节省手续费
功能增加
emode isolation 命名改变 例如： deposit命名为supply LendingPool.sol 命名为 Pool.sol, 等 核心业务逻辑全部移到 libraries/logic 目录中 (之前只有利率计算, validation的逻辑在 libraries/logic 目录中，包括新增的 emode，isolation，bridge) 外围功能单独 repo 类似于uniswap，有一个单独的 periphery 仓库。此外，deployment 好像也是一个单独的仓库，在安装aave-v3-core依赖时，会安装一个@aave/deploy-v3的包，但这个包目前找不到，issue在此：https://github.com/aave/aave-v3-core/issues/625
协议变更 如果要fork AAVE v3的同学注意了，这个协议好像类似于 uniswap v3的协议，具体可以去研究一下: https://github.com/aave/aave-v3-core/blob/master/LICENSE.md
(注: 不过好像大家fork的都是compound，很少有项目fork AAVE ^_^)
核心架构上变动不多 参考资料 https://governance.aave.com/t/introducing-aave-v3/6035
https://github.com/aave/aave-v3-core</content></entry><entry><title>使用 lua script 来执行 redis 事务</title><url>https://www.tiege.dev/post/2021-11/redis-lua-script-transaction/</url><categories><category>redis</category></categories><tags><tag>redis</tag><tag>lua script</tag><tag>transcation</tag><tag>一致性</tag></tags><content type="html"> redis 事务有两种实现方式，一种是通过 MULTI 命令 ， 另一种是使用 lua script. lua script 更简单, 而且 lua script 由于交互更少，且 redis 可以缓存 lua script，因此，效率更高，非常适合用于追求效率的地方。
lua script 官方文档: https://redis.io/commands/eval
redis的lua脚本执行有两个命令，一个是eval, 另一个是 evalsha.
eval 命令的语法：
> eval "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2], ARGV[3]}" 2 key1 key2 first second third 1) "key1" 2) "key2" 3) "first" 4) "second" 5) "third" 说明：
第二个字符串参数是执行的 lua 脚本，其中 KEYS ARGV 是关键字； 2 是指在 lua 脚本中，引用了两个 KEYS KEYS 用于指定 redis 的 key ARGV 就是后面的first second third 参数，在 KEYS 之后，序号从1开始 return 是返回的数据 如果服务端已经缓存了 lua 脚本，可以使用 evalsha 来执行，当脚本内容很多时，这样，传输的数据更少。
从redis 3.2.0开始，redis 中集成了 lua 调试工具，参考这里: https://redis.io/topics/ldb
使用示例 import "github.com/gomodule/redigo/redis" // redis lua 脚本, 确保预留分配多个时的原子操作 func ReserveUserToken(conn redis.Conn, accountID uint64, howmany uint32) (latest uint64, err error) { ss := `local sid=redis.call('HGET',KEYS[1],'latest') or 0; ` for i := 0; i &lt; int(howmany); i++ { ss += `redis.call('HSET', KEYS[1], sid, ARGV[1]); sid=sid+1; ` } // 更新 latest 值 ss += `redis.call('HSET', KEYS[1], 'latest', sid); return sid` script := redis.NewScript(1, ss) key := fmt.Sprintf("userTokens:%d", accountID) ts := time.Now().Unix() resp, err := script.Do(conn, key, ts) if err != nil { return } latest = uint64(resp.(int64)) return } 上述代码作用如下:
在 redis 上为每个用户生成 hashmap userToken:{accountId} , 如果没有，创建该hashmap，且将 hashmap 的 key latest 设置为 0; 如果 howmany 不为0，则为用户预留 token, 预留的方式为： 从 latest 增加1 作为key， 写入 hashmap 中 latest 自增 循环操作 将最新的 latest 写入 hashmap，并返回 值得注意的是，local sid=redis.call('HGET',KEYS[1],'latest') or 0; 这里一定要有最后的 or 0, 否则 sid 会是一个bool 类型，无法进行数值运算，会提示如下错误:
(error) ERR Error running script (call to f_2bd1a2e80fc04313100937b7b533da6bea026773): @user_script:1: user_script:1: attempt to perform arithmetic on local 'sid' (a boolean value) 几点补充 lua 判断 lua脚本判断的语法为：
if cond then clause else clause end 如果没有else，可以简化为：
if cond then clause end 当然，还有 elif 的语法。
整数与字符串 由于 redis 中的 key 是字符串类型，而 value 可以是整数。当你的key也是整数时，使用key与value相比时，将无法得到预期的结果，这是因为key为字符串类型，如果需要比较，可以用两种方法：
使用tonumber来转换 使用 +0 来强制转换 json 处理 redis中的lua脚本内置了cjson库，可以在lua脚本中直接使用cjson encode和decode来操作json数据。
encode 例子如下：
local user={name=ARGV[1],year=ARGV[2],address=ARGV[3]}; local userJson=cjson.encode(user); if redis.call('HSET', 'users', ARGV[1], userJson) == 0 then return -1 else return userJson end decode 类似:
local userJson = redis.call('HSET', 'users', ARGV[1]); local user = cjson.decode(userJson)</content></entry><entry><title>hardhat solidity 常见错误</title><url>https://www.tiege.dev/post/hardhat/hardhat-solidity-common-cases/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>hardhat</tag><tag>Solidity</tag><tag>hardhat-deploy</tag></tags><content type="html"> 常见 hardhat 相关问题整理 整理 hardhat， solidity 常见的错误，不定期更新。
hardhat-deploy: cannot find artifact &ldquo;xxxx&rdquo; 可能有两种情况:
确实没有该合约; 有重复的合约定义; 情况1的问题非常容易发现，由于错误提示的误导，情况2的却不容易被发现，因此，如果出现此类提示，请注意查看是否有多个重复的合约定义。
Error: Cannot find module &lsquo;typechain/dist/TypeChain&rsquo; 原因：使用旧版本的 hardhat-typechain 导致该问题，这个版本已经不在维护。
解决方案:
删除依赖 hardhat-typechain 增加依赖 typechain @typechain/hardhat @typechain/ethers-v5 yarn add -D typechain @typechain/hardhat @typechain/ethers-v5 修改 hardhat.config.ts: - import 'hardhat-typechain'; + import '@typechain/hardhat' https://github.com/dethcrypto/TypeChain/issues/409</content></entry><entry><title>openzeppelin 版本4.1.0-4.3.1中UUPS proxy 存在致命漏洞</title><url>https://www.tiege.dev/post/contract-proxy/uups-proxy-vulunerability/</url><categories><category>Defi</category><category>Solidity</category><category>安全</category></categories><tags><tag>Solidity</tag><tag>Proxy</tag><tag>vulunerability</tag><tag>openzeppelin</tag></tags><content type="html"> openzeppelin 的Proxy 有两种:
透明代理 Transparent proxy UUPS proxy 两者的最主要的区别是， upgradeTo 函数逻辑的位置。在透明代理中， upgradeTo 函数逻辑在proxy合约中；而在 UUPS 代理中， upgradeTo 函数逻辑在实现合约中。
漏洞 openzeppelin 的代理合约通常都由几个合约组成。每个可升级的部署都包括一个实现合约，实现合约中是可升级合约的逻辑；一个代理合约，保存合约的状态(也就是存储)。当代理合约升级时，将代理合约的实现地址指向行的实现地址即可。
代理合约升级示意图:
在版本4.1.0-4.3.1中，UUPSUpgradeable 合约的 upgradeTo 函数没有设置权限，任何人都可以调用该函数。因此，可以构造一个攻击合约，在攻击合约的 upgradeTo 中调用 SELFDESTRUCT, 然后调用实现合约的 upgradeTo, 参数为我们的攻击合约，这将导致实现合约销毁自己(这里很重要的一点是，调用 SELFDESTRUCT 不会导致失败！)，因此，代理合约的逻辑代码被销毁，导致整个合约宕机！
之前版本的 upgradeTo 函数的实现:
function upgradeTo(address newImplementation) external virtual { _authorizeUpgrade(newImplementation); _upgradeToAndCallSecure(newImplementation, bytes(""), false); } 4.3.2 版本 upgradeTo 函数的实现:
modifier onlyProxy() { require(address(this) != __self, "Function must be called through delegatecall"); require(_getImplementation() == __self, "Function must be called through active proxy"); _; } function upgradeTo(address newImplementation) external virtual onlyProxy { _authorizeUpgrade(newImplementation); _upgradeToAndCallSecure(newImplementation, new bytes(0), false); } 可以看到，现在实现合约的 upgradeTo 只有 proxy 合约可以调用。
UUPS 代理合约 upgradeTo 原理 UUPS合约的部署步骤如下：
首先，部署实现合约, 实现合约需继承合约 ERC1967UpgradeUpgradeable；
其次，部署 ERC1967Proxy 合约，在这个合约的初始化方法中，指定实现合约的地址为上一步部署的实现合约地址；
最后，调用 ERC1967Proxy 的 upgradeTo 函数。
upgradeTo 函数的代码：
function upgradeTo(address newImplementation) external virtual onlyProxy { _authorizeUpgrade(newImplementation); _upgradeToAndCallSecure(newImplementation, new bytes(0), false); } function _upgradeToAndCallSecure( address newImplementation, bytes memory data, bool forceCall ) internal { address oldImplementation = _getImplementation(); // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length > 0 || forceCall) { _functionDelegateCall(newImplementation, data); } // Perform rollback test if not already in progress StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT); if (!rollbackTesting.value) { // Trigger rollback using upgradeTo from the new implementation rollbackTesting.value = true; _functionDelegateCall( newImplementation, abi.encodeWithSignature("upgradeTo(address)", oldImplementation) ); rollbackTesting.value = false; // Check rollback was effective require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades"); // Finally reset to the new implementation and log the upgrade _upgradeTo(newImplementation); } } function _upgradeTo(address newImplementation) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); } function _setImplementation(address newImplementation) private { require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract"); StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation; } 其中， _authorizeUpgrade 是实现合约的权限验证，任何继承 ERC1967UpgradeUpgradeable 的合约都必须实现这个函数。这个函数通常是限制只有owner才能调用。
在 _upgradeToAndCallSecure 中，对新的实现合约执行了回滚测试 (rollbackTesting)，也就是，执行新的执行合约升级逻辑，使proxy升级到现在的实现合约，以确保新的实现合约的 upgradeTo 没有问题，确保新的实现合约可以继续升级。
当上述回滚测试没有问题时，将 _IMPLEMENTATION_SLOT 的地址设置为新的实现地址。
https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680</content></entry><entry><title>AAVE源代码分析 -- AAVE 部署及初始化</title><url>https://www.tiege.dev/post/aave/how-aave-deploy-and-initialize-contracts/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>deploy</tag><tag>Defi</tag><tag>initialize</tag></tags><content type="html"> 由于 AAVE 合约较多，因此 AAVE 的部署也比较复杂. AAVE 把部署分为7个任务，每个任务作为一个 hardhat task, 然后通过 full taks调用各个task，来完成整体的部署和初始化。
fulltask 在工程的 package.json 文件中，有几十个部署任务，其中，这个任务是部署主网并验证合约:
"aave:main:full:migration": "npm run compile &amp;&amp; npm run hardhat:main -- aave:mainnet --verify", 其中， aave:mainnet 是任务名称，这个任务的执行在 tasks\migrations\aave.mainnet.ts 文件中设定。文件主要内容如下:
// 1 部署 address provider 相关合约， POOL_NAME 为 Aave await DRE.run('full:deploy-address-provider', { pool: POOL_NAME, skipRegistry }); // 2 部署 lending pool 相关合约 await DRE.run('full:deploy-lending-pool', { pool: POOL_NAME }); // 3 部署 预言机 相关合约 await DRE.run('full:deploy-oracles', { pool: POOL_NAME }); // 4 部署 data-provider 相关合约 await DRE.run('full:data-provider', { pool: POOL_NAME }); // 5 部署 weth 网关 await DRE.run('full-deploy-weth-gateway', { pool: POOL_NAME }); // 6 初始化相关合约 await DRE.run('full:initialize-lending-pool', { pool: POOL_NAME }); if (verify) { printContracts(); // 7 验证合约 await DRE.run('verify:general', { all: true, pool: POOL_NAME }); // 8 验证 aToken 合约和 debt 合约 await DRE.run('verify:tokens', { pool: POOL_NAME }); } if (usingTenderly()) { } // 打印合约信息 printContracts(); 我们来看看每个task的任务.
1. full:deploy-address-provider 任务名称: full:deploy-address-provider
任务文件: tasks\full\1_address_provider.ts
任务说明： 部署 address registry 和 address provider
任务执行:
部署 LendingPoolAddressesProvider 合约, 参数 marketId (例如 Aave, AMM); 调用 add-market-to-registry 任务; 如果 registry 不存在, 调用 full:deploy-address-provider-registry 部署 LendingPoolAddressesProviderRegistry 合约 registerAddressesProvider setPoolAdmin setEmergencyAdmin 2. full:deploy-lending-pool 任务名称: full:deploy-lending-pool
任务文件: tasks\full\2_lending_pool.ts
任务说明： 部署 lending pool 及相关合约
任务执行:
如果 LendPool 合约未部署，部署相关 Library 和 LendPool 合约， 初始化 LendPool; 使用第一步创建的 address registry 为 LendPool 部署代理合约，并将实现的指向 LendPool 合约; 部署 LendingPoolConfigurator; 调用 addressesProvider.setLendingPoolConfiguratorImpl, 该函数为 LendingPoolConfigurator 部署Proxy， 并设置 address provider 中的 LendingPoolConfigurator 地址 部署 StableAndVariableTokensHelper 合约 部署 ATokensAndRatesHelper 合约 3. full:deploy-oracles 任务名称: full:deploy-oracles
任务文件: tasks\full\3_oracles.ts
任务说明: 部署预言机合约
任务执行:
如果 AaveOracle 合约不存在, 部署 AaveOracle 合约, 设置 setAssetSources; 如果 LendingRateOracle 合约不存在，部署 LendingRateOracle 合约，初始化 setInitialMarketRatesInRatesOracleByHelper 设置 addressesProvider 的 setPriceOracle 为 AaveOracle 合约地址 设置 addressesProvider 的 LendingRateOracle 为 LendingRateOracle 合约地址 4. full:data-provider 任务名称: full:data-provider
任务文件: tasks\full\4_data-provider.ts
任务说明: 部署 Data Provider 合约
任务执行:
部署 AaveProtocolDataProvider 合约 5. weth 网关合约 任务名称：full-deploy-weth-gateway
任务文件: tasks\full\5-deploy-wethGateWay.ts
任务说明: 部署 WETHGateway 合约
任务执行:
部署 WETHGateway 合约 6. 初始化合约 任务名称: full:initialize-lending-pool
任务文件: tasks\full\6-initialize.ts
任务说明： 部署合约，设置代理，初始化
任务执行:
initReservesByHelper，为市场上的每一个token，执行以下步骤: 部署 AToken 合约 部署 StableDebtToken 合约 部署 VariableDebtToken 合约 部署 DefaultReserveInterestRateStrategy 合约 调用 LendingPoolConfigurator 合约为 aToken 合约、debtToken 合约部署代理, 并初始化 aToken 合约，debtToken 合约， configureReservesByHelper， 如果 LendingPoolCollateralManager 不存在，部署 LendingPoolCollateralManager 合约 设置 addressesProvider 的 LendingPoolCollateralManager 地址 部署 WalletBalancerProvider 合约，这个合约是只读合约，提供一些数据 配置 WETHGateway 合约 7. 验证合约 验证合约基本就是调用 hardhat-etherscan 来验证合约。
Atoken/debtToken aToken, debtToken (VariableDebtToken, StableDebtToken) 都是通过代理来运行的, 代理方式有点类似于 openzeppelin 的透明代理模式.
LendingPoolConfigurator 合约是 aToken debtToken 的代理的创建者和管理者, 同时， 对 aToken debtToken 的初始化，升级;
同时, LendingPoolConfigurator 又是由 AddressProvider 合约创建代理合约代理, 并通过 AddressProvider 合约来管理升级的;</content></entry><entry><title>AAVE源代码分析 -- AAVE 闪电贷</title><url>https://www.tiege.dev/post/aave/aave-flashloan/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>flashloan</tag><tag>闪电贷</tag></tags><content type="html"> flashloan flashloan, 闪电贷, 是指在无需任何抵押, 一个交易内完成借款，还款的借贷行为。 核心是在一个交易内完成, 正因为在一个交易内完成, 所以才无需抵押, 也正是由于在一个交易内完成，闪电贷使用区块链交易事务的特性，可以检查还款的额度是否>借款+利息, 如果不够, 则交易回滚, 任何数据都被还原, 也就是说, 借给你的资金也同样回滚，因此，没有任何风险。
此外，闪电贷的利息收入非常可观。一个块，也就几秒钟、十几秒钟时间，收取万分之9的利率，而且，一般使用闪电贷的，都是极大的借款量，动辄几千万，上亿美金。
闪电贷是去中心化的一大创新, 不知道是不是 AAVE 首先提出的。 现在很多协议都提供了闪电贷功能，例如:
借贷平台，如 AAVE, Compound 也有外挂提供闪电贷的功能; AAVE 闪电贷的默认利率是万分之9; uniswap. uniswap 在 swap 时，同样提供闪电贷功能. swap 时, pair 合约先把买到的token发给你, 你可以用这个token去盈利，然后再把卖出的token转入pair中。uniswap不收取额外费用，只是兑换的手续费为千三; token. 现在一些token也提供闪电贷的功能, 原理类似。手续费看具体实现。 flashloan 的流程 流程如下：
验证参数数据(ValidationLogic.validateFlashloan); 计算需要支付的利息，并把 token 转给用户; 调用用户合约执行用户的代码; 增加利息, 并将连本带利数量的 token 从用户合约转入 (用户有抵押物的情况，也可以选择使用转入贷款) flashloan 的收益归谁 答案是归所有存款人所有。在借贷结束后，flashloan 更新了存款利率指数，也就意味着所有的存款人获得了利息收入。
_reserves[vars.currentAsset].updateState(); // 计入收益 _reserves[vars.currentAsset].cumulateToLiquidityIndex( IERC20(vars.currentATokenAddress).totalSupply(), vars.currentPremium ); // 更新年化利率 _reserves[vars.currentAsset].updateInterestRates( vars.currentAsset, vars.currentATokenAddress, vars.currentAmountPlusPremium, 0 ); // 将 token 转回来 IERC20(vars.currentAsset).safeTransferFrom( receiverAddress, vars.currentATokenAddress, vars.currentAmountPlusPremium ); 值得注意的是，与 uniswap 闪电贷不同的是， AAVE 的闪电贷时，用户合约执行完成后， token 的转移是在 AAVE 合约中发起，从用户合约转入，而不是让用户将 token 转入 AAVE 合约。</content></entry><entry><title>AAVE源代码分析 -- AAVE 利率代码分析</title><url>https://www.tiege.dev/post/aave/aave-interest-update-code/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>利率模型</tag></tags><content type="html"> AAVE 利率模型中，几个参数之间互相影响，关系错综复杂，其中，固定利率比较绕，尤其是计算平均固定利率的公式，尤其难懂。不过，在实际的借贷中，有很多token不支持固定利率借贷，而且，在支持固定利率借贷token中，使用固定利率的借贷比例也很小，几乎不到1%，因此，对于固定利率部分，对于初学者来说可以先跳过。
在 AAVE 的利率计算中, 有几个地方值得说明:
AAVE 的利率更新是基于时间戳来计算利息的增加, Compound 是根据块数来计算利息的增加；两者触发利率更新的方式相同，都是由存款，取款，借款，还款等几个动作触发，每个块只计算一次； 存款利率的增加是线性的，贷款利率的增加是复利，指数级； 贷款收益的 reserve factor% (默认10%) 纳入平台金库; aToken, debtToken 中的 balanceOf 方法，返回的 amount 都是存款/贷款对应的 token 数量; 如果你只需要知道结论，AAVE的几个核心流程可以简单的总结如下(代码在 LendingPool 合约中):
存款 Deposit
校验数据(ValidationLogic.validateDeposit) 更新状态: updateState 更新利率: updateInterestRates 将 token 从用户转入 LendingPool 合约 mint aToken给用户: aToken amount = token amount / liquidityIndex emit Deposit事件 取款 Withdraw
查询用户token资产数量，注意: 是token资产数量, 而不是 aToken 数量. 虽然这里调用的是 aToken.balanceOf(), 看上去好像是 aToken 的余额，但事件上，这个函数会计算当前块 aToken 对应的 token 的数量； 校验数据(ValidationLogic.validateWithdraw) 更新状态: updateState 更新利率: updateInterestRates 销毁用户的aToken，将对应的token转给用户 emit Withdraw 事件 借款 Borrow
通过价格预言机, 计算出借款对应的 ETH 价值 amountInETH (AAVE中所有的token都要换算为对应的ETH价值) 校验数据(ValidationLogic.validateBorrow) 更新状态: updateState 至关重要的一步：mint 对应的 debtToken, AAVE 的债务是通过 debtToken 来记录的，每个token 都会有对应的 stableDebtToken, variableDebtToken, 分别对应于定息借款和活息借款 更新利率: updateInterestRates 将用户借出的token转给用户 emit Borrow 事件 还款 Repay
查询定息借款和活息借款额度, 都是贷款 debtToken 对应的 token 的数量; 校验数据 (ValidationLogic.validateRepay) 更新状态: updateState 销毁 debtToken. 这里有一个很关键、很重要的细节，就是还款额度的计算: paybackAmount, 必须要非常仔细, 一旦出错, 就会造成重大损失 更新利率: updateInterestRates 将用户的 token 转入合约，完成还款 emit Repay 事件 最基本的操作就是以上这几个，其他的还有清算(专门讨论), 转换借款方式(定息转活息，活息转定息)
从上面的流程可以看出:
updateState 和 updateInterestRates 是两个非常关键的函数，所有的操作都要调用这两个方法； 对这两个方法的调用稍有不同，例如 存款，取款时，两个方法是一起调用的； 而借款中，在两个方法的调用之间，还有其他操作；为什么会这样呢? 所有利率的变化，都是由 updateState 和 updateInterestRates 计算并更新的，下面我们来看看这两个函数的实现细节。
updateState updateInterestRates 两个函数定义如下:
function updateState(DataTypes.ReserveData storage reserve) internal; function updateInterestRates( DataTypes.ReserveData storage reserve, address reserveAddress, address aTokenAddress, uint256 liquidityAdded, uint256 liquidityTaken ) internal; 这两个函数在 library ReserveLogic.sol 中, 传入的参数中都有 DataTypes.ReserveData storage reserve , ReserveData 我们前面介绍过，是储存利率相关字段的结构体; 这个参数的存储类型是 storage, 说明这两个函数可以直接修改合约中的状态。
updateState updateState 主要作用: 0. 获取最新的活息贷款数量, 即 variableDebtToken 的总数量;
更新存款利率指数(ReserveData.liquidityIndex)和活息贷款利率指数(ReserveData.variableBorrowIndex), 通过 _updateIndexes 方法 将产生的增量贷款利息的一部分(reserve factor) 存入小金库, 具体实现的方式是 mint Atoken 给 treasy 地址 updateInterestRates updateInterestRates 主要作用: 0. 更新 currentLiquidityRate;
更新 currentStableBorrowRate 更新 currentVariableBorrowRate 关键函数 _updateIndexes 一个细节是，虽然资金变化都每次都调用，但由于在一个块内，只有第一次调用时 liquidityIndex 和 variableBorrowIndex 发生变化，后续调用都不会变化，因为 timestamp 相同， calculateCompoundedInterest 和 calculateLinearInterest 都是返回 Ray(1e27).
不知道是否可以优化, 我提了一个issue: https://github.com/aave/protocol-v2/issues/237
function _updateIndexes( DataTypes.ReserveData storage reserve, uint256 scaledVariableDebt, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 timestamp // 上次更新的时间戳 ) internal returns (uint256, uint256) { // currentLiquidityRate 是在 updateInterestRates 中更新的 uint256 currentLiquidityRate = reserve.currentLiquidityRate; uint256 newLiquidityIndex = liquidityIndex; uint256 newVariableBorrowIndex = variableBorrowIndex; //only cumulating if there is any income being produced if (currentLiquidityRate > 0) { // 存款利率根据 currentLiquidityRate 线性累加 // 公式: cumulatedLiquidityInterest = currentLiquidityRate * (block.timestamp-timestamp)/SECONDS_PER_YEAR uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp); newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex); require(newLiquidityIndex &lt;= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW); // 更新存款利息指数 reserve.liquidityIndex = uint128(newLiquidityIndex); //as the liquidity rate might come only from stable rate loans, we need to ensure //that there is actual variable debt before accumulating if (scaledVariableDebt != 0) { // 计算这段时间累加的活息贷款利息, 复利方式计算 // 计算的实现是 泰勒级数展开 uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp); newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex); require( newVariableBorrowIndex &lt;= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW ); // 更新活息贷款利息指数 reserve.variableBorrowIndex = uint128(newVariableBorrowIndex); } } // 设置更新时间戳 //solium-disable-next-line reserve.lastUpdateTimestamp = uint40(block.timestamp); return (newLiquidityIndex, newVariableBorrowIndex); } updateInterestRates 更新年化利率
function updateInterestRates( DataTypes.ReserveData storage reserve, address reserveAddress, address aTokenAddress, uint256 liquidityAdded, uint256 liquidityTaken ) internal { UpdateInterestRatesLocalVars memory vars; vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress; // 定息借款 (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress) .getTotalSupplyAndAvgRate(); // 活息贷款, 折算为 token //calculates the total variable debt locally using the scaled total supply instead //of totalSupply(), as it's noticeably cheaper. Also, the index has been //updated by the previous updateState() call vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress) .scaledTotalSupply() .rayMul(reserve.variableBorrowIndex); // 根据利率策略，计算新的存款年化利率 活息贷款年化利率 定息贷款年化利率. calculateInterestRates 见下文分析 ( vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates( reserveAddress, aTokenAddress, liquidityAdded, liquidityTaken, vars.totalStableDebt, vars.totalVariableDebt, vars.avgStableRate, reserve.configuration.getReserveFactor() ); require(vars.newLiquidityRate &lt;= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW); require(vars.newStableRate &lt;= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW); require(vars.newVariableRate &lt;= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW); // 新的利率 reserve.currentLiquidityRate = uint128(vars.newLiquidityRate); reserve.currentStableBorrowRate = uint128(vars.newStableRate); reserve.currentVariableBorrowRate = uint128(vars.newVariableRate); emit ReserveDataUpdated( reserveAddress, vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate, reserve.liquidityIndex, reserve.variableBorrowIndex ); } calculateInterestRates 代码如下：
struct CalcInterestRatesLocalVars { uint256 totalDebt; uint256 currentVariableBorrowRate; uint256 currentStableBorrowRate; uint256 currentLiquidityRate; uint256 utilizationRate; } /** * @dev Calculates the interest rates depending on the reserve's state and configurations. * NOTE This function is kept for compatibility with the previous DefaultInterestRateStrategy interface. * New protocol implementation uses the new calculateInterestRates() interface * @param reserve The address of the reserve * @param availableLiquidity The liquidity available in the corresponding aToken * @param totalStableDebt The total borrowed from the reserve a stable rate * @param totalVariableDebt The total borrowed from the reserve at a variable rate * @param averageStableBorrowRate The weighted average of all the stable rate loans * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market * @return The liquidity rate, the stable borrow rate and the variable borrow rate **/ function calculateInterestRates( address reserve, uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 averageStableBorrowRate, uint256 reserveFactor ) public view override returns ( uint256, uint256, uint256 ) { CalcInterestRatesLocalVars memory vars; // 总借款 = 活息借款 + 定息借款 vars.totalDebt = totalStableDebt.add(totalVariableDebt); vars.currentVariableBorrowRate = 0; vars.currentStableBorrowRate = 0; vars.currentLiquidityRate = 0; // 资金利用率 = 总借款 / (总存款+总借款) // 忽略 rayDiv rayMul, 可以简单的认为是 div mul 即可 vars.utilizationRate = vars.totalDebt == 0 ? 0 : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt)); vars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle()) .getMarketBorrowRate(reserve); // 利率曲线: 两段式 // 资金利用率高于最佳利用率时，利率的计算 if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) { uint256 excessUtilizationRateRatio = vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE); vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add( _stableRateSlope2.rayMul(excessUtilizationRateRatio) ); vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add( _variableRateSlope2.rayMul(excessUtilizationRateRatio) ); } else { vars.currentStableBorrowRate = vars.currentStableBorrowRate.add( _stableRateSlope1.rayMul(vars.utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE)) ); vars.currentVariableBorrowRate = _baseVariableBorrowRate.add( vars.utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE) ); } // currentLiquidityRate的计算 = (加权平均借款利率/总借款) * 资金利用率 * (1-储备率) // 加权平均借款利率 = (活息借款*活息利率 + 定息借款*平均定息利率) / 总借款 vars.currentLiquidityRate = _getOverallBorrowRate( totalStableDebt, totalVariableDebt, vars .currentVariableBorrowRate, averageStableBorrowRate ) .rayMul(vars.utilizationRate) .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor)); return ( vars.currentLiquidityRate, vars.currentStableBorrowRate, vars.currentVariableBorrowRate ); } /** * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt * @param totalStableDebt The total borrowed from the reserve a stable rate * @param totalVariableDebt The total borrowed from the reserve at a variable rate * @param currentVariableBorrowRate The current variable borrow rate of the reserve * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans * @return The weighted averaged borrow rate 加权平均借款利率: (活息借款*活息利率 + 定息借款*平均定息利率) / 总借款 **/ function _getOverallBorrowRate( uint256 totalStableDebt, uint256 totalVariableDebt, uint256 currentVariableBorrowRate, uint256 currentAverageStableBorrowRate ) internal pure returns (uint256) { uint256 totalDebt = totalStableDebt.add(totalVariableDebt); if (totalDebt == 0) return 0; uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate); uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate); uint256 overallBorrowRate = weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay()); return overallBorrowRate; } } 为什么要先调用 updateState, 然后再调用 updateInterestRates 简单的说，是因为 liquidityIndex 和 variableBorrowIndex 是由 currentLiquidityRate 和 currentVariableBorrowRate 计算出来的，而先调用 updateState, 然后再调用 updateInterestRates，就是说，在时刻 t1, 当存款或贷款无论变化多少次，liquidityIndex 和 variableBorrowIndex只变化一次； 而 currentLiquidityRate， currentVariableBorrowRate 和 currentStableBorrowRate 会随着金额的变化而变化。
在一个块中，liquidityIndex 和 variableBorrowIndex只变化一次, 这里 AAVE 的代码不如 Compound, 如果是同一个块，多了很多无用的运算；
就是说，你存款后，下一个块才开始有利息；同理，贷款也是如此。
定息贷款的 averageStableBorrowRate averageStableBorrowRate 对于定息贷款很重要， 影响到 资金使用率，进而影响到 存款利率。
averageStableBorrowRate 在 StableDebtToken.sol 合约中定义，在 mint 和 burn 是改变该值。
mint:
// _calculateBalanceIncrease 返回值: 贷款本金，本息合计，利息 (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf); // 用户新的平均贷款利率 = 某种加权平均??? vars.newStableRate = _usersStableRate[onBehalfOf] .rayMul(currentBalance.wadToRay()) .add(vars.amountInRay.rayMul(rate)) // rate 是入参， 值为 reserve.currentStableBorrowRate .rayDiv(currentBalance.add(amount).wadToRay()); require(vars.newStableRate &lt;= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW); // 每个用户都有一个_usersStableRate， 保存用户贷款时的利率 _usersStableRate[onBehalfOf] = vars.newStableRate; //solium-disable-next-line _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp); // 该 token 总的定息贷款平均利率, 与上面的更新逻辑一致 // Calculates the updated average stable rate vars.currentAvgStableRate = _avgStableRate = vars .currentAvgStableRate .rayMul(vars.previousSupply.wadToRay()) .add(rate.rayMul(vars.amountInRay)) .rayDiv(vars.nextSupply.wadToRay()); burn:
if (previousSupply &lt;= amount) { // 当定息贷款被还完时，清零 // 由于可能存在计算误差, 这里不能使用 previousSupply - amount _avgStableRate = 0; _totalSupply = 0; } else { nextSupply = _totalSupply = previousSupply.sub(amount); uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay()); uint256 secondTerm = userStableRate.rayMul(amount.wadToRay()); // For the same reason described above, when the last user is repaying it might // happen that user rate * user balance > avg rate * total supply. In that case, // we simply set the avg rate to 0 if (secondTerm >= firstTerm) { newAvgStableRate = _avgStableRate = _totalSupply = 0; } else { newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay()); } } 由于定息贷款用户的利息和平台的利息是独立计算的，感觉这里两个数据会存在不一致。</content></entry><entry><title>下一代撮合引擎 -- 基于消息驱动的并行撮合引擎</title><url>https://www.tiege.dev/post/matching-engine/next-generation-matching-engine-parallel-matching-engine-base-on-message/</url><categories><category>Defi</category><category>Matching-engine</category></categories><tags><tag>Matching-engine</tag><tag>Matching</tag><tag>撮合</tag><tag>撮合引擎</tag><tag>并行撮合</tag><tag>kafka</tag><tag>消息队列</tag><tag>交易所</tag><tag>CLOB</tag></tags><content type="html"> 中心化交易所都是基于CLOB (中央统一订单薄)进行撮合交易, 撮合交易的交易原则是价格优先，时间优先。撮合引擎对于交易所来说，是基石，是重中之重。撮合引擎需要稳定，高效，可扩展，且能够容灾，同时，要保证在极端行情下和故障的情况下，可以迅速恢复或者回滚。
基于消息驱动的并行撮合 这里提出一种基于消息驱动的并行撮合引擎，首先，基于消息驱动是指，撮合引擎的输入有且只有消息队列(例如kafka)；其次，什么是 并行撮合 ?
并行撮合是指，多台机器对订单同时撮合，不是1主N从的方式，也不是 Round-Robin，而是 同时撮合. 那么，一个很明显的问题，这样不会出现数据混乱吗？答案是在持久层(包括redis，数据库)，我们需要做可重入处理。也就是说，同一个订单(同一个消息id标识)，即使被撮合引擎撮合无数次，在持久层的状态也只会变化一次。
实现并行撮合，最为重要的有两点：一是状态机；一是可重入。
状态机 并行撮合的原理是，如果我们把撮合引擎看做一个状态机，输入是 kafka 消息，输出是下一个状态。该状态机依赖于上一个状态和输入消息，用数学表达如下:
f(0) = 初始状态 f(t) = f(m(t), f(t-1)) 其中: f(t) 是消息 t 对应的状态; m(t) 是消息 t 对于撮合引擎而言，当系统载入初始数据后，撮合过程不再依赖环境变量，也不依赖任何随机数据，对于数据的处理，结果是完全确定的。因此，从理论上说，撮合系统，在相同的初始条件，相同的输入，必然产生相同的输出，这就是并行撮合的原理。也就是说，我们不需要像传统的做法那样，在多台撮合引擎之间通过多播协议来同步数据，而是靠相同的初始条件，相同的输入数据，相同的处理流程，以及定时检查，来保证在 同一消息点 上，各个撮合引擎之间的数据的一致性。
Ok，撮合引擎之间的数据一致性可以保证了，这只是整个系统容灾的一小部分，对于整个系统来说，每个环节都是需要确保正确，可容灾。
可重入 可重入的数学表达式:
f(x) = f(f(x)) 即，对同样的输入x, 无论执行多少次，最终的结果是一样的。
对于持久存储，例如redis和数据库，我们通过 kafka sequece id 来保证不可重入。
首先，对于一个订单生命周期的每一次变动，都是由kafka消息触发的。例如，订单的创建，由用户发送买入或卖出请求触发；订单的撮合，是由新订单的进入触发；订单的结束，是撮合的结果，自然也是新的订单触发； 其次，用户的资产变动，也可以认为是由消息触发。用户的资产变动，主要由以下几个方面:
充币 提币 OTC 各种交易 最后，从更大的层面来说，不单是订单，资产，我们可以将所有的输入，都抽象为消息，然后，整个系统的任何变动，都是由基于消息触发。通过在持久层实现可重入，那么我们的整个系统就可以通过
问题来了，如何实现，如何保证正确性，如何保证一致性，如何容灾？
sequence id 作为状态同步的尺度 先是架构图： 架构图对应的消息流程如下：
消息进入kafka队列; 各台撮合引擎分别从kafka中读取数据，并独立撮合； 撮合引擎将撮合结果写入redis HA, redis HA 通过消息id来保证数据的可重入; 撮合引擎 写入redis成功 后，将需要修改的数据发送给kafka； 由其他模块结束步骤3的消息，延迟写入数据库。 kafka 是我们的核心单元，kafka的每一条消息都有一个sequence id，这是一个64位自增的正整数。sequence id 是我们的衡量状态的尺度, 我们依赖 kafka 的 sequence id 来保证数据的一致性。具体来讲，对于订单数据，我们保存在三个地方，撮合引擎的内存中，redis中，数据库中。我们需要保证的是，三者对于同一个 sequence id, 这三个地方对应的订单状态是一致的。
如何保证撮合引擎的数据一致性 理论上，每台撮合引擎初始数据一致，处理相同的消息，并且是按照相同的顺序处理，因此，在同一个消息点上，所有撮合引擎的内存中的orderbook是应该完全一致的。
当然，这只是理论上的。为了实际保证撮合的一致性，并能够检查验证这一结果，我们可以在kafka中设计一种消息，当撮合引擎收到此类消息时，计算内存中所有orderbook的hash值，然后发送给kafka，撮合引擎接收其他撮合引擎的hash值，并与自己的对比，如果hash值相同，则证明数据一致；如果不同，则需要撮合引擎对各个价位取hash，并继续比较，直到找到不同之处，然后由开发工程师分析为何会出现不一致。
我们可以非常频繁的对比撮合结果，例如，每10秒钟执行一次，这样，一旦出现不一致，我们可以快速根据当时的数据来分析定位问题。
上述是检查的措施，如果发生不一致的情况，如何处理？例如，我们已经确定了问题所在，并打算以某台撮合的数据为基准。这时，我们可以通过定义同步消息，让正确的撮合引擎把完整的orderbook发送给kafka，其他撮合引擎使用这个 orderbook 来覆盖自己原有的 orderbook 即可，跟启动时同步数据一样的流程。
其他撮合引擎启动时如何同步数据 由于数据在三个地方都有，因此，撮合引擎数据的同步可以从三个地方获取:
其他撮合引擎的内存中 redis中 数据库中 从1中获取最好，因为这是最新的数据，而且在撮合引擎中，具有更好的一致性，而从redis和数据库中，如果是集群的话，需要考虑是否数据的存储方式。具体来讲，如果我们需要同步一个交易对的 orderbook，在redis中，如果 orderbook 保存在cluster的多台机器上，这时，我们去读取orderbook的状态时，就很难保证在多台redis上读取到的数据对应的 sequence id 相同。
从撮合引擎同步数据，可以按照这样的流程来实现：
向kafka发送请求同步消息; 撮合引擎响应消息，将orderbook的数据发给kafka； 待同步的撮合引擎读取orderbook数据，拿到orderbook和这个状态所对应的sequence id，初始化orderbook后，从kafka 的这个 sequence id开始读取数据，并处理。 如果这时，主撮合引擎失败了，如何处理？由于这时没有任何撮合引擎继续处理消息，因此，redis集群和数据库集群都是停留在最后一个kafka 消息id对应的状态上，当然，由于数据库的状态同步比redis慢，我们优先从redis中同步数据。因为状态不在发生变化，这时，所有redis集群对应的kafka消息id都是一致的，因此，只需要把redis cluster中的数据读出来，然后恢复出orderbook即可。
如何容灾 因为多台机器同时撮合, 因此，该方案本身天生就是容灾的! 只需要保证所有撮合系统的内存在同一消息点的数据一致性即可。
定期检查机制 通过 kafka 发送 检查指令 消息, 撮合引擎收到该消息后, 对本引擎的交易对的 orderbook 做 hash 运算, 然后将结果发出来对比，必须保证多台撮合引擎的 hash 值完全一致, 否则就需要定位排查为何 hash 值不一致。
优化 按照上面的方案，撮合引擎发送到kafka的消息会成倍的增长，由此带来后续的处理负荷也会成倍增加。如何优化这个架构？通过上面的分析，我们知道，
实现细节 我们后续会讨论一些实现的细节，例如撮合使用的数据结构，redis的存储格式，redis事务等。
方案优势 多台撮合引擎解耦 多台撮合引擎数据时刻一致 易于升级，易于测试 实时验证, 实时监测 缺点 消息量增加 1/N 倍 (架构1增加N倍，架构2增加1倍)
redis 写入次数增加 N 倍</content></entry><entry><title>AAVE源代码分析 -- AAVE Proxy 体系</title><url>https://www.tiege.dev/post/aave/how-aave-proxy/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>智能合约代理</tag></tags><content type="html"> 智能合约代理 智能合约为了能够升级的需求，重要的合约基本都是代理模式。AAVE 的代理非常复杂，要想深入理解 AAVE 的代理体系，就需要剥茧抽丝，一层一层的去仔细研究，才能理解其精髓。
AAVE 代理全局图：
按照 openzeppelin 对代理的定义, 智能合约的代理通常分为两种类型， 一种是透明代理(transparent)，一种是 uups 代理。两种代理的区别是:
目前， openzeppelin 更推荐使用 uups 方式的代理，更易用，也更简洁。
LendingPoolAddressesProvider 首先，要讲一下位于核心地位的 LendingPoolAddressesProvider 合约，这个合约是一个注册中心，也是一个管理中心。这个合约主要有两个作用:
创建、升级、管理其他合约； 作为注册中心，报错各个合约的地址，并未其他合约提供地址, 其他合约通过 LendingPoolAddressesProvider 来查询其他合约的地址; 以下几个核心合约都是通过这个合约创建、升级、初始化、管理的:
LENDING_POOL LENDING_POOL_CONFIGURATOR LendingPoolAddressesProvider，从名字可以看出，这个合约的一大功能就是提供 Address, 为谁提供 Address 呢？ 以下地址通过 LendingPoolAddressesProvider 来配置:
LENDING_POOL LENDING_POOL_CONFIGURATOR LENDING_POOL_COLLATERAL_MANAGER POOL_ADMIN EMERGENCY_ADMIN PRICE_ORACLE LENDING_RATE_ORACLE LendingPoolAddressesProvider 是如何创建、管理合约的呢？大概的步骤如下:
合约创建时，会先创建一个 Proxy 模板，然后把具体的实现设置到 Proxy 合约中； 上面几个合约中，都有一个 addressesProvider 变量，初始化第一步创建的合约时，将本合约的地址作为参数，初始化; 这几个合约需要相互调用，当调用时，首先通过 addressesProvider 来获取对方的地址，然后再调用。 创建其他合约的Proxy并设置代理的代码如下：
// 升级或创建合约 function _updateImpl(bytes32 id, address newAddress) internal { address payable proxyAddress = payable(_addresses[id]); InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(proxyAddress); bytes memory params = abi.encodeWithSignature('initialize(address)', address(this)); if (proxyAddress == address(0)) { // 代理合约不存在时，先创建代理合约模板，然后初始化代理合约 proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this)); proxy.initialize(newAddress, params); _addresses[id] = address(proxy); emit ProxyCreated(id, address(proxy)); } else { // 已经存在时, 升级合约 proxy.upgradeToAndCall(newAddress, params); } } LendingPoolConfigurator 与 LendingPoolAddressesProvider, LendingPoolConfigurator 用来创建以下合约的代理:
AToken StableDebtToken VariableDebtToken 代码如下:
function _initTokenWithProxy(address implementation, bytes memory initParams) internal returns (address) { // 部署 proxy 合约 InitializableImmutableAdminUpgradeabilityProxy proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this)); // 将proxy合约的实现指向 implementation, 并初始化 proxy 合约 proxy.initialize(implementation, initParams); return address(proxy); } 升级合约:
function _upgradeTokenImplementation( address proxyAddress, address implementation, bytes memory initParams ) internal { InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress)); proxy.upgradeToAndCall(implementation, initParams); } 关系图：</content></entry><entry><title>uniswap 环回交易的手续费</title><url>https://www.tiege.dev/post/uniswap/uniswap-loopback-swap-fee/</url><categories><category>Defi</category><category>uniswap</category></categories><tags><tag>uniswap</tag><tag>uniswap v2</tag><tag>Defi</tag><tag>Solidity</tag><tag>套利</tag><tag>arbitrage</tag></tags><content type="html"> uniswap 的交易费用，是通过 x * y = K 的恒等式中推导而来, 在特定的交易场景时，例如环回交易中，我们的交易成本可以做到远远低于额定手续费。
什么是环回交易 环回交易是在一个交易对 tokenA/tokenB 交易，先从 tokenA 兑换得到 tokenB, 然后立刻将得到的 tokenB 换回 tokenA 的交易。
uniswap v2 的标准费率是千分之三, 那么环回交易的成本就是千分之六, 这个成本相当之高. 如果我们仅仅是为了刷交易量, 我们需要一种有效的途径来降低手续费, 环回交易就是一种非常有效的途径。
理论推导 下面是我们的详细推导过程. 假设如下:
dx: 输入的 tokenA 数量 r0: tokenA 的 reserve 数量 r1: tokenB 的 reserve 数量 dy: 第一次 tokenA -> tokenB swap 的数量 ex: 第二次 swap tokenB -> tokenA 的数量 根据uniswap的公式, 计算如下：
dy = dx*997*r1/(1000*r0 + dx*997) R1 = r1 - dy R0 = r0 + dx ex = dy*997*R0/(1000*R1 + dy*997) 代入dy，化简后，可得：
ex = 997*997*dx*(r0+dx) / (1000*1000*r0 + 997*997*dx) 同时除以dx：
ex/dx = 997*997*(r0+dx) / (1000*1000*r0 + 997*997*dx) 由于ex是最终环回交易结束时我们的 tokenA 数量, dx 是我们 tokenA 的输入数量, 1-ex/dx 就是我们的手续费比例。
从上面的公式可知，最终环回交易的ex只跟输入dx和tokenA的reserve有关，而且，输入数量dx与tokenA reserve比值越高，最终得到的ex/dx 越接近1，也就是付出的手续费越少。
代码演算 测试代码如下：
Filename: loopbackSwap.js
const BigNumber = require('ethers').BigNumber const e18 = BigNumber.from('1000000000000000000') const getAmountOut = (amountIn, r0, r1) => { const amountInWithFee = amountIn.mul(997) , numerator = amountInWithFee.mul(r1) , denominator = r0.mul(1000).add(amountInWithFee); return numerator.div(denominator) } const getAmountBack = (amtIn, r0, r1, printable = false) => { const out = getAmountOut(amtIn, r0, r1) r0 = r0.add(amtIn) r1 = r1.sub(out) const dx = getAmountOut(out, r1, r0) if (printable) { console.info('swap x->y: out=%s r0=%s r1=%s backx=%s', out.toString(), r0.toString(), r1.toString(), dx.toString()) } return { amtInter: out, amtOut: dx } } function loopbackSwap() { const reserveA = BigNumber.from(1000000).mul(e18) , reserveB = BigNumber.from(2000000).mul(e18) , ratio = (multor) => reserveA.mul(multor).div(1000) let amts = [ 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 3000, 5000, 10000 ] for (let amt of amts) { let amtIn = ratio(amt) let { amtOut } = getAmountBack(amtIn, reserveA, reserveB) console.info('dx/reserve=%s amtOut/amtIn=%s', amt/1000, amtOut.mul(10000).div(amtIn).toNumber()/10000) } } loopbackSwap() run the scripts:
npx hardhat run loopbackSwap.js dx/reserve=0.001 amtOut/amtIn=0.994 dx/reserve=0.002 amtOut/amtIn=0.994 dx/reserve=0.005 amtOut/amtIn=0.994 dx/reserve=0.01 amtOut/amtIn=0.994 dx/reserve=0.02 amtOut/amtIn=0.9941 dx/reserve=0.05 amtOut/amtIn=0.9942 dx/reserve=0.1 amtOut/amtIn=0.9945 dx/reserve=0.2 amtOut/amtIn=0.995 dx/reserve=0.5 amtOut/amtIn=0.9959 dx/reserve=1 amtOut/amtIn=0.9969 dx/reserve=2 amtOut/amtIn=0.9979 dx/reserve=3 amtOut/amtIn=0.9984 dx/reserve=5 amtOut/amtIn=0.9989 dx/reserve=10 amtOut/amtIn=0.9994 从结果可以看出，当 dx/reserve 超过1后，手续费率极速降低，当dx/reserve=10，手续费仅为万分之6
由此，可以使用闪电贷，在较低的利率下，将大量资金从借贷池中借出，然后进行环回交易，在一些交易即挖矿的交易所中，可以通过这种方式降低挖矿手续费，套利获利。
实战 我们可以编写一个合约来执行我们的环回交易。
需要注意的是，我们不能直接将 uniswap router 的 path 参数设置为 [tokenA, tokenB, tokenA] 来进行环回交易，而必须分成两次swap, 首先是 [tokenA, tokenB]， 然后是 [tokenB, tokenA].
示例代码如下：
/// @dev swapLoopback swap tokenA to tokenB, then swap tokenB to tokenA /// @param _router uniswap-like router /// @param reward the reward token /// @param amountIn amount in /// @param amountOutMin just set to 0 /// @param path [tokenA, tokenB] function swapLoopback( address _router, // router address reward, // reward token uint amountIn, uint amountOutMin, address[] memory path ) public onlyOwner { address tokenIn = path[0]; uint tokenInitial = IERC20(tokenIn).balanceOf(address(this)); _approve(IERC20(tokenIn), address(_router)); // solhint-disable-next-line uint256 ts = block.timestamp + 60; uint[] memory amounts = IUniswapRouter(_router).swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), ts); path[0] = path[1]; path[1] = tokenIn; // console.log("amounts:", amounts[1]); _approve(IERC20(path[0]), address(_router)); amounts = IUniswapRouter(_router).swapExactTokensForTokens(amounts[1], amountOutMin, path, address(this), ts); // other arbitrage code with reward.. reward; }</content></entry><entry><title>元交易及其实现</title><url>https://www.tiege.dev/post/meta-transaction-and-implement/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag><tag>EIP-712</tag><tag>meta-transaction</tag></tags><content type="html"> 什么是元交易 简单来说，元交易(meta transaction)就是由第三方代理用户发送的交易。
元交易的流程如下：
用户构建交易参数，对交易参数签名 第三方将交易签名发送至 Relay/Forwarder 合约 Relay/Forwarder 合约验证用户的签名是否相符 Relay/Forwarder 调用最终的合约 普通的交易如下图所示:
元交易的如下图所示:
注： 图中的 Relayer 就是本文的 Forwarder 合约
元交易可以用来做什么 元交易大体有两个用途:
我们知道，去中心化的体验门槛很高，普通用户要玩去中心化，起码需要： a. 下载交易所，充币，认证，购买以太坊 b. 安装metamask，记住助记词，生吃地址； c. 交易所提币； d. 了解去中心化dapp, 理解原理, 使用dapp 上述任何一个步骤都非常麻烦，一整套流程走下来，半天就过去了
因此，使用元交易，可以让用户没有以太，就可以体验 dapp
安全 假如你有冷钱包，里面有很多钱，你不想让冷钱包直接触网，这时，你可以使用这种方式，让 Relayer/Forwarder 合约作为你的代理发送交易。
如何实现元交易 我们构建这样的一个数据结构:
struct ForwardRequest { // 用户地址 address from; // 用户要调用的合约地址 address to; // 交易发送的以太数量 uint256 value; // 设置的gas费, 可以不需要 uint256 gas; // Forwarder合约中记录的用户的nonce, 防止重放攻击 uint256 nonce; // 用户调用的函数和参数 bytes data; } 用户签名 待签名数据的构建基于 EIP-712, 如下:
/// @notice Returns a hash of the given data, prepared using EIP712 typed data hashing rules. /// @param from origin sender /// @param to contract to call /// @param value send ETH value /// @param nonce from's nonce /// @param data encodewithselector contract call params /// @return digest hash digest function getDigest( address from, address to, uint256 value, uint256 nonce, bytes memory data ) public view returns (bytes32 digest) { digest = _hashTypedDataV4( keccak256(abi.encode(_TYPE_HASH, from, to, value, nonce, keccak256(data)))); } 函数 _hashTypedDataV4 是根据 EIP-712 实现的, 代码如下:
function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) { return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash); } function _domainSeparatorV4() internal view returns (bytes32) { return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash()); } function _buildDomainSeparator( bytes32 typeHash, bytes32 nameHash, bytes32 versionHash ) private view returns (bytes32) { return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this))); } 其中，_EIP712NameHash _EIP712VersionHash 是合约创建时设置的
然后, 使用用户的私钥对上面算出来的 digest 签名:
import { utils } from 'ethers' const userkey = new utils.SigningKey(privateKey) , sig = userkey.signDigest(digest) , sigs = utils.joinSignature(sig) 合约验证签名合法性 验证签名的合法性基于两点:
ecrecover 从digest，签名中解出的地址与用户地址一致
nonce ForwardRequest.req 结构体中的 nonce 与合约中记录的nonce一致
验签代码如下:
using ECDSAUpgradeable for bytes32; function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) { bytes32 digest = getDigest(req.from, req.to, req.value, req.nonce, req.data); address signer = digest.recover(signature); return _nonces[req.from] == req.nonce &amp;&amp; signer == req.from; } msg.sender 的问题 当 Forwarder 合约最终调用 to 合约时，to 合约中使用 msg.sender 时, msg.sender 值为 Forwarder 合约地址。如果需要在 to 合约中使用用户地址，则需要做一些修改。
首先，Forwarder 合约调用 to 合约时，已经将用户的地址附加在调用参数的后面。to 合约的被调用函数并不需要知道这个参数的存在，因为 to 合约的函数取哪些参数，如何获取这些参数是在合约编译时，已经确定了, to 合约只是按照偏移量去 sload 数据. 在最后增加一个参数不会影响原来参数的获取，也不会像c/c++那样破坏堆栈。
Forwarder合约的执行:
(bool success, bytes memory returndata) = req.to.call{value: req.value}( abi.encodePacked(req.data, req.from) ); 这样，Forwarder 合约就把用户的地址传给了 to 合约，剩下的就交给 to 合约了。
然后，to 合约要怎么得到用户地址呢?
我们先来看看 openzeppelin 的 Context 合约:
abstract contract Context { function _msgSender() internal view virtual returns (address) { return msg.sender; } function _msgData() internal view virtual returns (bytes calldata) { return msg.data; } } 这是一个非常基础的合约，很多合约就是基于 Context 合约. 最开始看到这两个函数时，我非常迷惑, _msgSender() 就是简单的返回 msg.sender, 有什么作用呢？实际上，绝大部分时候，我们都是直接使用 msg.sender, 很少调用 _msgSender()。
在处理元交易时， _msgSender() 的作用就体现出来了, 我们可以重写 _msgSender 函数，来得到 用户地址，当然，前提是 to 合约需要配置 Forwarder 合约的地址。
在 to 合约中， 重写 _msgSender 函数代码如下：
address private _trustedForwarder; function isTrustedForwarder(address forwarder) public view virtual returns (bool) { return forwarder == _trustedForwarder; } function _msgSender() internal view virtual override(ContextUpgradeable) returns (address sender) { if (isTrustedForwarder(msg.sender)) { // The assembly code is more direct than the Solidity version using `abi.decode`. assembly { sender := shr(96, calldataload(sub(calldatasize(), 20))) } } else { return msg.sender; } } function _msgData() internal view virtual override(ContextUpgradeable) returns (bytes calldata) { if (isTrustedForwarder(msg.sender)) { return msg.data[:msg.data.length - 20]; } else { return msg.data; } } 这样, 就完成了对 to 合约的修改。 openzeppelin 的代码都是使用 _msgSender 来获取 msg.sender, 如果 to 合约继承了 openzeppelin 合约，那么继承的函数就直接支持了元交易。
此外，还有一种解决方式，就是在 to 合约中提供一个函数来设置用户的地址，Forwarder 调用 to 合约前，调用该函数设置用户地址；to合约执行时，从临时变量中读取用户地址; 执行完成后, Forwarder 合约在把地址重置。
显然这种方案没有第一种方案优雅，而且需要一个storage变量来存储用户地址，也增加了 gas 费用。
安全问题 重放攻击 例如，一个转账交易，如果没有检查，再次用同样的参数调用，就有可能再次转账。
解决的方式有很多种，一种是在 合约中为用户记录nonce值，每次交易自增nonce；另一种是记录交易hash，不允许重复的交易hash
样例代码 https://github.com/guotie/meta-tx
包含了使用, 部署，测试，Proxy 代理的实现。</content></entry><entry><title>AAVE源代码分析 -- AAVE 利率</title><url>https://www.tiege.dev/post/aave/aave-interest-model/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag></tags><content type="html"> 利率模型和风险控制是借贷协议的核心, 在AAVE中，利率的更新可以分为三个部分:
存币利率 活息借款利率 定息借款利率 至于风险控制，在后面的章节中，我们单独讨论。
ReserveData 结构体 ReserveData 是 AAVE 利率变动的核心数据结构。ReserveData 在 contracts\protocol\libraries\types\DataTypes.sol 文件中定义，相关代码如下：
// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties. struct ReserveData { // stores the reserve configuration // 各种配置, 就是一个 uint256, 不同的配置项使用不同为, 简单的 bitmask 算法 ReserveConfigurationMap configuration; // the liquidity index. Expressed in ray // 存币利率指数: aToken 与 token 的换算关系 uint128 liquidityIndex; // variable borrow index. Expressed in ray // 活息借款利率指数 uint128 variableBorrowIndex; // the current supply rate. Expressed in ray // 活息借款利率与定息借款利率的加权平均 uint128 currentLiquidityRate; // the current variable borrow rate. Expressed in ray // 活息借款利率 uint128 currentVariableBorrowRate; // the current stable borrow rate. Expressed in ray // 定息借款利率 uint128 currentStableBorrowRate; uint40 lastUpdateTimestamp; // tokens addresses address aTokenAddress; address stableDebtTokenAddress; address variableDebtTokenAddress; // address of the interest rate strategy address interestRateStrategyAddress; // the id of the reserve. Represents the position in the list of the active reserves uint8 id; } ReserveData 是借贷关系最核心的结构体, 每个市场上可以借贷的币种，都有一个对应的 ReserveData , 用来记录该币对的各种利率。
与利率相关的变量:
liquidityIndex: 存币利率 variableBorrowIndex: 活息借款利率 currentLiquidityRate: 流动率, 用于更新 liquidityIndex currentStableBorrowRate: 定息借款率 currentVariableBorrowRate: 活息借款率, 用于更新 variableBorrowIndex 两段式利率 利率的核心是供求关系。每当资金发生变化时，AAVE 都会自动调整利率. 利率的调整是基于供求关系，在 AAVE 或 Compound 中，反映资金供求关系的变量是资金利用率。资金利用率的定义是：
Utilisation = 总借款 / (总存款+总借款) 总借款 = 活息借款 + 定息借款 利率随供求关系变化的示意图：
这个图很清晰的说明了利率的变化:
当使用率不超过最佳使用率时, 利率 = 基本利率 + 使用率 * slope1-rate 当使用率超过最佳使用率时, 利率 = 基本利率 + slope1-rate + (使用率-最佳使用率) * slope2-rate 从图中可知, 当使用率超过最佳使用率时，利率上涨的速度非常快, 这促使借款人尽快归还借款，否则，就很有可能被清算。
liquidityIndex 这是指标是 token/atoken 的存币利率
主要用到的地方:
存币 deposit 将用户的token转入合约，mint aToken并转给用户.
将 token mint 为 atoken，换算关系为:
atoken 数量 = token 数量 / liquidityIndex 取回 withdraw 将用户的 aToken 转入合约并销毁, 将对应的 token 转给用户
token 数量 = atoken 数量 * liquidityIndex 由于 liquidityIndex 在不断增长, 由上面两个公式就可以算出用户的存币利息所得。
variableBorrowIndex 借款利率 活息借款 当用户借款时, 系统会给用户 mint 借款的代币, 用来记录用户的借款, 已经随时间变化产生的利息.
varDebtToken 数量 = token 数量 / variableBorrowIndex 活息还款 当用户还款时，需要还的数量通过以下公式计算:
token 数量 = varDebtToken 数量 * variableBorrowIndex 清算 清算是风控的核心，在风控章节详细讨论。
定息借款 定息借款与活息借款类似，但有所不同。由于使用定息借款的比例非常少, 这里暂时跳过对定息借款的分析
利率的计算过程 利率的计算主要在文件 contracts\protocol\lendingpool\DefaultReserveInterestRateStrategy.sol 中，函数名为 calculateInterestRates.
计算的大概过程是:
总借款 = 活息借款 + 定息借款 资金利用率 = 总借款 / (总存款+总借款) 计算活息利率和定息利率。这两个利率都是两段式计算, 每一段的变化都是线性的。 a. 活息利率 = 基本活息利率 + 资金利用率 * slope1活息 (如果超过第一段, 还需要计算第二段的利率) b. 定息利率 = 基本定息利率 + 资金利用率 * slope1定息 加权平均借款利率 = (活息借款活息利率 + 定息借款平均定息利率) / 总借款， 这里的平均定息利率是函数入参，不再这里计算 currentLiquidityRate = (加权平均借款利率/总借款) * 资金利用率 * (1-储备率) 可以看到, currentLiquidityRate 的计算最复杂, 那么这个变量的用途是什么呢? 答案是用来计算存款利率(liquidityIndex)
对于利率的相关代码的分析，见: AAVE 利率代码解析
AAVE系列文章:
AAVE借贷协议简介 AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 清算; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 测试及部署;</content></entry><entry><title>AAVE源代码分析 -- AAVE代码整体架构</title><url>https://www.tiege.dev/post/aave/how-aave-interest-update/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag><tag>architecture</tag></tags><content type="html"> AAVE 整体架构 AAVE是一个借贷协议, 因此, 核心是围绕着存款，借款，还款，清算这四大环节展开的。我认为, AAVE 之所以看起来很复杂, 非常重要的一点是因为定息借款的存在, 极大的提高了利率模型的复杂度, 否则, AAVE 应该更加清晰。
AAVE 架构图如下:
目录结构及文件 合约主要在 contracts 目录下, contracts 目录结构如下：
├─adapters // 外部合约适配层 │ └─interfaces ├─dependencies // 一些基础库, 大部分基于 openzeppelin 修改 │ └─openzeppelin │ ├─contracts │ └─upgradeability ├─deployments // 部署相关 ├─flashloan // 闪电贷 │ ├─base │ └─interfaces ├─interfaces // 接口定义 ├─misc │ └─interfaces ├─mocks // 测试相关 │ ├─attacks │ ├─dependencies │ │ └─weth │ ├─flashloan │ ├─oracle │ │ └─CLAggregators │ ├─swap │ ├─tokens │ └─upgradeability └─protocol // 核心实现, 核心代码全部在这个目录下 ├─configuration ├─lendingpool ├─libraries │ ├─aave-upgradeability │ ├─configuration │ ├─helpers │ ├─logic │ ├─math │ └─types └─tokenization └─base 结合 AAVE 的部署代码, 算上Mock合约, AAVE 大概有 30 个合约:
LendingPoolAddressesProvider = 'LendingPoolAddressesProvider', LendingPoolAddressesProviderRegistry = 'LendingPoolAddressesProviderRegistry', LendingPoolParametersProvider = 'LendingPoolParametersProvider', LendingPoolConfigurator = 'LendingPoolConfigurator', ValidationLogic = 'ValidationLogic', ReserveLogic = 'ReserveLogic', GenericLogic = 'GenericLogic', LendingPool = 'LendingPool', PriceOracle = 'PriceOracle', Proxy = 'Proxy', LendingRateOracle = 'LendingRateOracle', AaveOracle = 'AaveOracle', DefaultReserveInterestRateStrategy = 'DefaultReserveInterestRateStrategy', LendingPoolCollateralManager = 'LendingPoolCollateralManager', InitializableAdminUpgradeabilityProxy = 'InitializableAdminUpgradeabilityProxy', WalletBalanceProvider = 'WalletBalanceProvider', AToken = 'AToken', DelegationAwareAToken = 'DelegationAwareAToken', AaveProtocolDataProvider = 'AaveProtocolDataProvider', StableDebtToken = 'StableDebtToken', VariableDebtToken = 'VariableDebtToken', FeeProvider = 'FeeProvider', TokenDistributor = 'TokenDistributor', StableAndVariableTokensHelper = 'StableAndVariableTokensHelper', ATokensAndRatesHelper = 'ATokensAndRatesHelper', UiPoolDataProvider = 'UiPoolDataProvider', WETHGateway = 'WETHGateway', UniswapLiquiditySwapAdapter = 'UniswapLiquiditySwapAdapter', UniswapRepayAdapter = 'UniswapRepayAdapter', FlashLiquidationAdapter = 'FlashLiquidationAdapter', 以下是 Mock 合约 MockAToken = 'MockAToken', MockAggregator = 'MockAggregator', WETHMocked = 'WETHMocked', SelfdestructTransferMock = 'SelfdestructTransferMock', MockStableDebtToken = 'MockStableDebtToken', MockVariableDebtToken = 'MockVariableDebtToken', MockFlashLoanReceiver = 'MockFlashLoanReceiver', MockUniswapV2Router02 = 'MockUniswapV2Router02', MintableERC20 = 'MintableERC20', // mock MintableDelegationERC20 = 'MintableDelegationERC20', // mock 借贷核心 借贷核心包括:
利率的计算 AAVE 将利率的计算移到了三个library中，路径为 contracts\protocol\libraries\logic\, 主要是: GenericLogic.sol 计算用户 account
ReserveLogic.sol 核心中的核心, 各种利率的计算
ValidationLogic.sol 这个库主要是各种安全校验, 存款校验, 借款校验, 还款校验, 清算校验, 转账校验, 活息定息转换校验等等
LendPool LendPool 是借贷动作的入口, 包括存款，借款，还款，清算等动作。
LendingPoolCollateralManager 主要负责完成清算
DefaultReserveInterestRateStrategy 利率变化的策略：calculateInterestRates
tokenization AAVE 中用户的存款，借款都是以 token 的方式记录。Compound 中，只有存款是以 token 的方式记录，借款并没有 tokenization. 其实, 我觉得借款并没有 tokenization 的必要。
AToken 存款凭证，类似于 Compound 中的 cToken。当用户存入 token 时，AAVE 给用户 mint 对应的 aToken
DelegationAwareAToken AToken 的代理
StableDebtToken 定息借款 token, 用于记录用户的定息借款
VariableDebtToken 活息借款 token, 用于记录用户的活息借款
市场及Provider、配置管理 LendingPoolAddressesProvider LendingPoolAddressesProviderRegistry LendingPoolParametersProvider LendingPoolConfigurator Oracle 辅助合约 AaveProtocolDataProvider 把一些整合并计算好, 方便前端调用
UiPoolDataProvider 把一些整合并计算好, 方便前端调用
StableAndVariableTokensHelper 辅助管理合约, 同时设置多个 asset 的 borrowRate
WalletBalanceProvider 查询 balance 信息, 并不是很必要, 实际上可以通过 multicall 来完成这样的功能。当然, 这样可以更有针对性的获取数据, 速度也更快
ATokensAndRatesHelper 辅助管理合约, 设置配置信息
adapter 主要是 uniswap adapter，包括以下几个合约:
UniswapLiquiditySwapAdapter UniswapRepayAdapter FlashLiquidationAdapter Proxy LendPool 的 proxy 这么多合约确实让人眼花缭乱，然而，我们可以先从核心开始分析，也就是利率模型和风险控制相关的合约，大约7-8个合约。</content></entry><entry><title>About</title><url>https://www.tiege.dev/about/</url><categories/><tags/><content type="html"> 铁叔 老年程序员，以代码为生计，正在为世界的去中心化事业而奋斗。
Older programmers, who coding for a living, and fighting for a decentralize world.
projects technology Rust golang C/C++ smart contract &amp; solidity java/Spring frontend</content></entry><entry><title>solidity函数selector的计算</title><url>https://www.tiege.dev/post/evm-selector/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag></tags><content type="html"> solidity 中有函数选择器(selector)的概念.
什么是 selector 在 solidity 中，所有 public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。
evm 函数选择器是一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节(高位在左的大端序) (译注：这里的 高位在左的大端序，指最高位字节存储在最低位地址上的一种串行化编码方式，即高位字节在左)。 这种签名被定义为基础原型的规范表达，基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。
简单来说，就是函数原型的 sha-3 hash值。
selector 有什么用途 在 以太坊Ethereum 生态系统中， 应用二进制接口 Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。
我们假定合约函数的接口都是强类型的，且在编译时是可知的和静态的；不提供自我检查机制。我们假定在编译时，所有合约要调用的其他合约接口定义都是可用的。
这份手册并不针对那些动态合约接口或者仅在运行时才可获知的合约接口。如果这种场景变得很重要，你可以使用 以太坊Ethereum 生态系统中其他更合适的基础设施来处理它们。
官方说明： https://docs.soliditylang.org/en/v0.8.7/abi-spec.html
如何计算 selector selector 可以通过两种方式获取，一种是查询 function.selector，另一种就是自己计算。
写个简单的测试合约，就能秒懂。
// SPDX-License-Identifier: MIT pragma solidity >=0.6.0; pragma experimental ABIEncoderV2; interface IABI { function initialize(address a, address b, address c, address d) external; } contract ABI { function initiliaze(address a, address b, address c, address d) public { } function getCodeByKeccak() public pure returns (bytes4) { return bytes4(keccak256(bytes("initialize(address,address,address,address)"))); } function getCodeBySelector() public view returns (bytes4) { IABI addr = IABI(address(this)); return addr.initialize.selector; } } 当计算函数选择器(selector)时，计算传入bytes数组有两点需要注意：
函数参数只有类型，没有名称，例如上例中的 initialize(address,address,address,address) 参数中间没有空格！参数中间没有空格！参数中间没有空格！ 如果要在链下计算，可以通过 ethers 提供的工具函数 id，代码如下：
import { id } from 'ethers/lib/utils'; const hash = id('initialize(address,address,address,address)') , selector = hash.slice(0, 10) selector 重复怎么办？ 如果一个合约中有重复的 selector，编译器会报错。
如果函数原型的参数是自定义的结构体, 怎么办? 如果是结构体, 在计算 selector 时, 将结构体展开为 tuple 来计算。例如：
struct Reward { address ctoken; address underlying; uint256 amount; uint256 debt; uint256 pending; address benefit; address owner; address[] path; }, function calcReward(Reword r, address to) returns (uint256); 在计算函数 calcReward 的selector时, 实际上是计算
calcReward((address,address,uint256,uint256,uint256,address,address,address[]),address) 这个字符串的 id
对于比较复杂的情况，我建议使用 ethers 库的 Interface 来计算函数的 selector, 链接: https://docs.ethers.io/v5/api/utils/abi/interface/
根据ABI创建 Interface
使用 Interface.getSighash() 获取函数的 selector
使用 Interface.getFunction('xxx').format('sighash') 获取计算 selector 的函数签名
完整的示例如下:
const { expect } = require("chai"); const { ethers } = require("hardhat"); describe("ABI selector", function() { it('selector', async () => { const iface = new ethers.utils.Interface([ // Constructor "constructor(string symbol, string name)", // State mutating method "function transferFrom(address from, address to, uint amount)", // State mutating method, which is payable "function mint(uint amount) payable", // Constant method (i.e. "view" or "pure") "function balanceOf(address owner) view returns (uint)", // An Event "event Transfer(address indexed from, address indexed to, uint256 amount)", // A Custom Solidity Error "error AccountLocked(address owner, uint256 balance)", // Examples with structured types "function addUser(tuple(string name, address addr) user) returns (uint id)", "function addUsers(tuple(string name, address addr)[] user) returns (uint[] id)", "function getUser(uint id) view returns (tuple(string name, address addr) user)" ]); console.log('addUsers getSighash: %s', iface.getSighash('addUsers')) let addUserFormat = iface.getFunction('addUsers').format(ethers.utils.FormatTypes.getSighash) console.log('addUsers format: %s', addUserFormat) console.log('addUsers selector:', ethers.utils.id(addUserFormat).slice(0, 10)) }) })</content></entry><entry><title>AAVE源代码分析 -- AAVE借贷协议简介</title><url>https://www.tiege.dev/post/aave/brief-introduction-to-aave-protocol/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag></tags><content type="html"> DEFI 上最初的应用就是借贷应用。借贷，顾名思义，是一个允许用户借贷代币的智能合约，它与银行类似，存款人把钱存入到借贷应用中(更具体的说，就是某个智能合约)，借贷应用把你的钱借给借款人，并随着时间的推移赚取利息。当借款人资不抵债时，会触发清算，任何人都可以参与清算，清算成功时清算人将获取一定比例的清算奖励。同时，借贷应用的清算系统能够确保借贷系统的稳定，进而保证存款人的利益。
DEFI 借贷在以下几个方面与银行不同:
利息的计算; a. DEFI 借贷利息的计算是从你存入的块开始计算，到你取出的块停止计算； b. DEFI 借贷的利息浮动范围很广，跟资金利用率(可以简单理解为 贷出资金/总借贷金额)息息相关，大多数借贷系统都设置比例，当资金利用率超过该比例时，利息会上涨的非常快，且利息很高，因此，这对于借款人来说，是非常不利的; c. 所有借款都必须有超额抵押，不存在信用贷款的概念;
清算 a. DEFI 借贷的所有存入，借出都是公开透明的; b. DEFI 借贷的清算标准是固定的; c. 任何人都可以进行清算，并且，清算人可以获取丰厚的清算奖励，通常是清算金额10% d. 由于清算奖励的巨大诱惑，且公开透明的数据，可以保证清算工作的稳定运行；
闪电贷 闪电贷是 AAVE 的一个巨大创新，所谓闪电贷，不是银行的闪电贷，这里的闪电贷是指，在一个区块交易中，同时完成先贷后还的操作。举个例子，现在有一个套利机会，但是你有没有资金，这时候，你就可以使用闪电贷，借出资产，完成套利，归还资金和利息，剩下的就是你的套利收益。
闪电贷也被很多人用于合约攻击，获取更大的收益。最近发生的很多起攻击事件，都是使用闪电贷的资金作为来源。
存款标的。 你可以将很多标的存入银行，由银行来对你的标的进行资产评估；而 DEFI 借贷只能存入部分 token, 因为 token 有公开定价, 而资产评估必须要链下评估，难以在链上完成。 DEFI 的借贷经历了三个发展阶段, 第一阶段的代表作是 MakerDAO, 第二阶段的代表作是 Compound, 第三阶段的代表作是 AAVE.
毫无疑问, Makerdao 是开创者; Compound 重新设计了利率模型, 可以说此后所有的借贷模型都是在 Compound 的基础之上发展而来, 从而奠定了 Compound 的江湖地位; AAVE 则是集大成者, AAVE 的借贷模型与 Compound 相同, 与Compound, MakerDAO 相比, AAVE 有以下特点:
AAVE 最大的创新就是引入了 闪电贷 (flashloan) 这个大杀器, 从此以后, 只有在链上有机会套利或者攻击, 你根本不用担心资金问题; 闪电贷也是链上借贷的独特优势, 在传统的金融行业中, 根本不存在这样的功能; AAVE 还有固定利率功能。我们知道, Compound 的利率是在不断的变化的，跟资金使用率息息相关, 当资金使用率突然升高时，借款利率会急速上升，对于长期资金使用者来说，这是无法承受的，AAVE引入了固定利率，从而解决了有长期资金需求借款人的借贷问题； AAVE 的代码比 Compound 写的更好, 更加工整, 框架清晰, 可读性, 可维护性都比 Compound 高几个档次 AAVE 更加安全。AAVE 的代码质量更高，模块化、结构化更好，测试更加充分，安全性更高。前几天 Cream protocol 发生的被攻击事件，让 Cream 损失了几千万美元。如果 Cream 当初是 fork 了 AAVE 的代码，这个攻击就无法进行。原理后面再详细分析 与swap市场 uniswap 一家独大不同，目前，借贷市场还处于三国鼎立的阶段，MakerDao, Compound, AAVE 各有优势, AAVE 在存款数量上有一定优势, Compound用户数最多，群众基础较好; MakerDao 锁仓金额较多；当然，这三者各有所长，差距不是非常明显, 其他模仿者就和这三大巨头的差距比较大，在没有大的创新的情况下，很难挑战这三大巨头。
由于 AAVE 比 Compound 代码更复杂，因此，目前 bsc、heco 这些链上的借贷市场几乎都是 fork Compound 代码，同时，由于这些团队追求快速上线，也没有对 Compound 进行深入研究，导致最终上线的产品不敢改也不能改，最多的就是把 cToken 改成各种 xToken，反正圈钱发币为主，不影响使用。
从学习的角度看，AAVE 代码质量非常优秀，比 Compound 高出好几个档次, AAVE v1版本就已经非常规范，v2版本更是青出于蓝而胜于蓝，从各个方面来看，都堪称典范:
结构非常清晰，interface, library, 实现，核心代码，适配层分门别类，各司其职； 完整的测试代码； 完整的部署代码； 完善的官方文档，白皮书等； 完善的周边 sdk，代码示例； 统一的代码风格，统一的注释风格，所有函数都有注释； 完善的代码检查，lint； Library 的应用真是炉火纯青 WETHGateway 的引入，统一了 ETH 和 Token, 这一点我觉得比 uniswap 做的好，uniswap 的 Router 合约有很多专门为 ETH 服务的接口，如果改成这种方式，会更加清晰； 教科书级别 Proxy 应用, 当然, 目前 openzeppelin 的代理是更加通用的解决方案 唯一能与之相提并论的是 uniswap, 当然, uniswap 把前端界面也开源了， 而 AAVE 并没有开源前端界面, 这是 AAVE 不如 uniswap 的地方。
我们将推出有一系列的文章来讲解 AAVE 的代码: 0. AAVE借贷协议简介
AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 风险控制; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 部署;</content></entry><entry><title>libuv与TCP Keepalive</title><url>https://www.tiege.dev/post/libuv-and-tcp-keepalive/</url><categories><category>c/c++</category></categories><tags><tag>libuv</tag><tag>tcp</tag><tag>TCP Keepalive</tag><tag>linux</tag></tags><content type="html"> libuv 与 TCP Keepalive 关于 keepalive 这里的keepalive与HTTP的keepalive不同，这里的keepalive是TCP层的keepalive，用处是当两台机器之间通信时，中间网络出现故障，这时，两端并无法感知网络故障这个事件，无法及时发现网络故障。
HTTP的keepalive是指，一个请求在请求头部增加一个keep alive的行，这时，服务端传输完成后，不会关闭这个TCP连接，还可以继续下次HTTP请求，提高了效率。
Linux内核关于TCP keepalive的说明在这里： http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html
其中：
tcp_keepalive_time the interval between the last data packet sent (simple ACKs are not considered data) and the first keepalive probe; after the connection is marked to need keepalive, this counter is not used any further tcp_keepalive_intvl the interval between subsequential keepalive probes, regardless of what the connection has exchanged in the meantime tcp_keepalive_probes the number of unacknowledged probes to send before considering the connection dead and notifying the application layer 大致翻译一下就是
tcp_keepalive_time 当一台机器在 N 秒内，还没有收到对方的任何数据时，开始 keepalive 探测对方是否正常 tcp_keepalive_intvl keepalive报文发送的间隔，单位秒 tcp_keepalive_probes keepalive报文探测次数 也就是说，在 tcp_keepalive_time 秒内仍未收到对端数据时，开始发起 keepalive 探测，每隔 tcp_keepalive_intvl 发送一个探测报文，当 发送 tcp_keepalive_probes 探测报文，对方仍未响应时，关闭连接。
在Linux下，可以通过以下方式查看系统的keepalive配置：
[root@localhost ~]# cat /proc/sys/net/ipv4/ 1800 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_probes 9 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_intvl 75 keepalive 接口 设置一个套接字的keepalive的方法如下：
1. enable keepalive int on = 1; if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) { // log return -1; } 2. 设置 tcp_keepalive_time int idle = 10; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(int)) &lt; 0) { // log return -1; } 3. 设置 tcp_keepalive_probes int probes = 4; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;probes, sizeof(int)) &lt; 0) { // log return -1; } 4. 设置 tcp_keepalive_intvl int intvl = 1; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;intvl, sizeof(int)) &lt; 0) { // log return -1; } libuv 的 keepalive libuv提供的接口只能设置上面的两个：
enable keepalive 设置 tcp_keepalive_time libuv提供的接口为 uv_tcp_keepalive, 函数原型如下：
int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) Enable / disable TCP keep-alive. delay is the initial delay in seconds, ignored when enable is zero. 该函数的实现代码如下：
int uv__tcp_keepalive(int fd, int on, unsigned int delay) { if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) return -errno; #ifdef TCP_KEEPIDLE if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;delay, sizeof(delay))) return -errno; #endif /* Solaris/SmartOS, if you don't support keep-alive, * then don't advertise it in your system headers... */ /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ #if defined(TCP_KEEPALIVE) &amp;&amp; !defined(__sun) if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &amp;delay, sizeof(delay))) return -errno; #endif return 0; } int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) { int err; if (uv__stream_fd(handle) != -1) { err =uv__tcp_keepalive(uv__stream_fd(handle), on, delay); if (err) return err; } if (on) handle->flags |= UV_TCP_KEEPALIVE; else handle->flags &amp;= ~UV_TCP_KEEPALIVE; /* TODO Store delay if uv__stream_fd(handle) == -1 but don't want to enlarge * uv_tcp_t with an int that's almost never used... */ return 0; } 从上面的代码可以看出，当 uv__stream_fd(handle) 不成功时，仅仅设置该连接的flags位，实际上并没有用到delay这个参数。也就是说，只有当连接已经成功建立时，才能设置 tcp_keepalive_time，如果连接还没有建立成功，则这个值根本没有设置。
如果要设置后面两个数值的话，需要自己实现, 示例代码如下：
// // 设置 keepalive 相关的2个参数 // probes: 对应内核 tcp_keepalive_probes, 发送多少次keepalive报文还未收到回应时, close该连接 // intvl: 对应内核 tcp_keepalive_intvl, 发送keepalive报文的间隔时间 // idle: 对应内核 tcp_keepalive_time int set_keep_alive(const uv_handle_t* handle, int probes, int intvl, int idle) { int ret; uv_os_fd_t fd; ret = uv_fileno(handle, &amp;fd); if (ret &lt; 0) { return ret; } if (idle > 0) { if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(idle))) return -1; } // 设置 tcp_keepalive_intvl if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (const void *) &amp;intvl, sizeof(int)) &lt; 0 ) { return -1; } // 设置 tcp_keepalive_probes if ( setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (const void *) &amp;probes, sizeof(int)) &lt; 0) { return -1; } return 0; } 这个函数只能在连接建立成功后调用，因为只有连接建立成功才有fd，即uv_fileno才会返回成功。</content></entry><entry><title/><url>https://www.tiege.dev/post/2021-11/nestjs-prisma/</url><categories/><tags/><content type="html"> nest new project-name
cd project-name
npm i prisma graphql @nestjs/graphql class-validator apollo-server-express dotenv graphql-fields graphql-modules reflect-metadata type-graphql typegraphql-nestjs graphql-type-json
npx prisma init
编辑.env， 配置DATABASE_URL
npx prisma introspect
npx prisma generate</content></entry><entry><title/><url>https://www.tiege.dev/post/futures-perps/a-great-sheet-of-perp-protocols/</url><categories/><tags/><content type="html"/></entry><entry><title/><url>https://www.tiege.dev/post/matching-engine/02-matching-engine-details/</url><categories/><tags/><content type="html"> redis 高可用 redis 事务 orderbook 在 redis 中的存储 数据库结构及订单存储 撮合引起启动时初始数据，及同步验证 启动
异步 哪些可以异步，哪些必须顺序执行?
故障定位，故障解决 性能</content></entry><entry><title/><url>https://www.tiege.dev/post/postgres/postgres/</url><categories/><tags/><content type="html"> Postgresql 13.x 安装(Linux) https://www.postgresql.org/download/linux/redhat/
CentOS 7安装步骤：
# Install the repository RPM: sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm # Install PostgreSQL: sudo yum install -y postgresql13-server # Optionally initialize the database and enable automatic start: sudo /usr/pgsql-13/bin/postgresql-13-setup initdb sudo systemctl enable postgresql-13 sudo systemctl start postgresql-13 初始化 修改密码 sudo su - postgres psql -U postgres ALTER USER postgres with encrypted password 'GIFT.$$$2021.$$$Stock.$$$.go'; exit sudo systemctl restart postgresql-13.service 连接配置</content></entry><entry><title/><url>https://www.tiege.dev/post/solidity/solidity-decompile/</url><categories/><tags/><content type="html"> https://www.trustlook.com/services/smart.html https://eveem.org/</content></entry></search>