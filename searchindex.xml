<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>AAVE源代码分析 -- AAVE Proxy 体系</title><url>https://www.tiege.dev/post/aave/how-aave-proxy/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>智能合约代理</tag></tags><content type="html"> 智能合约代理 智能合约为了能够升级的需求，重要的合约基本都是代理模式。AAVE 的代理非常复杂，要想深入理解 AAVE 的代理体系，就需要剥茧抽丝，一层一层的去仔细研究，才能理解其精髓。
AAVE 代理全局图：
按照 openzeppelin 对代理的定义, 智能合约的代理通常分为两种类型， 一种是透明代理(transparent)，一种是 uups 代理。两种代理的区别是:
目前， openzeppelin 更推荐使用 uups 方式的代理，更易用，也更简洁。
LendingPoolAddressesProvider 首先，要讲一下位于核心地位的 LendingPoolAddressesProvider 合约，这个合约是一个注册中心，也是一个管理中心。这个合约主要有两个作用:
创建、升级、管理其他合约； 作为注册中心，报错各个合约的地址，并未其他合约提供地址, 其他合约通过 LendingPoolAddressesProvider 来查询其他合约的地址; 以下几个核心合约都是通过这个合约创建、升级、初始化、管理的:
LENDING_POOL LENDING_POOL_CONFIGURATOR LendingPoolAddressesProvider，从名字可以看出，这个合约的一大功能就是提供 Address, 为谁提供 Address 呢？ 以下地址通过 LendingPoolAddressesProvider 来配置:
LENDING_POOL LENDING_POOL_CONFIGURATOR LENDING_POOL_COLLATERAL_MANAGER POOL_ADMIN EMERGENCY_ADMIN PRICE_ORACLE LENDING_RATE_ORACLE LendingPoolAddressesProvider 是如何创建、管理合约的呢？大概的步骤如下:
合约创建时，会先创建一个 Proxy 模板，然后把具体的实现设置到 Proxy 合约中； 上面几个合约中，都有一个 addressesProvider 变量，初始化第一步创建的合约时，将本合约的地址作为参数，初始化; 这几个合约需要相互调用，当调用时，首先通过 addressesProvider 来获取对方的地址，然后再调用。 创建其他合约的Proxy并设置代理的代码如下：
// 升级或创建合约 function _updateImpl(bytes32 id, address newAddress) internal { address payable proxyAddress = payable(_addresses[id]); InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(proxyAddress); bytes memory params = abi.encodeWithSignature('initialize(address)', address(this)); if (proxyAddress == address(0)) { // 代理合约不存在时，先创建代理合约模板，然后初始化代理合约 proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this)); proxy.initialize(newAddress, params); _addresses[id] = address(proxy); emit ProxyCreated(id, address(proxy)); } else { // 已经存在时, 升级合约 proxy.upgradeToAndCall(newAddress, params); } } LendingPoolConfigurator 与 LendingPoolAddressesProvider, LendingPoolConfigurator 用来创建以下合约的代理:
AToken StableDebtToken VariableDebtToken 代码如下:
function _initTokenWithProxy(address implementation, bytes memory initParams) internal returns (address) { // 部署 proxy 合约 InitializableImmutableAdminUpgradeabilityProxy proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this)); // 将proxy合约的实现指向 implementation, 并初始化 proxy 合约 proxy.initialize(implementation, initParams); return address(proxy); } 升级合约:
function _upgradeTokenImplementation( address proxyAddress, address implementation, bytes memory initParams ) internal { InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress)); proxy.upgradeToAndCall(implementation, initParams); } 关系图：</content></entry><entry><title>uniswap 环回交易的手续费</title><url>https://www.tiege.dev/post/uniswap/uniswap-loopback-swap-fee/</url><categories><category>Defi</category><category>uniswap</category></categories><tags><tag>uniswap</tag><tag>uniswap v2</tag><tag>Defi</tag><tag>Solidity</tag><tag>套利</tag><tag>arbitrage</tag></tags><content type="html"> uniswap 的交易费用，是通过 x * y = K 的恒等式中推导而来, 在特定的交易场景时，例如环回交易中，我们的交易成本可以做到远远低于额定手续费。
什么是环回交易 环回交易是在一个交易对 tokenA/tokenB 交易，先从 tokenA 兑换得到 tokenB, 然后立刻将得到的 tokenB 换回 tokenA 的交易。
uniswap v2 的标准费率是千分之三, 那么环回交易的成本就是千分之六, 这个成本相当之高. 如果我们仅仅是为了刷交易量, 我们需要一种有效的途径来降低手续费, 环回交易就是一种非常有效的途径。
理论推导 下面是我们的详细推导过程. 假设如下:
dx: 输入的 tokenA 数量 r0: tokenA 的 reserve 数量 r1: tokenB 的 reserve 数量 dy: 第一次 tokenA -> tokenB swap 的数量 ex: 第二次 swap tokenB -> tokenA 的数量 根据uniswap的公式, 计算如下：
dy = dx*997*r1/(1000*r0 + dx*997) R1 = r1 - dy R0 = r0 + dx ex = dy*997*R0/(1000*R1 + dy*997) 代入dy，化简后，可得：
ex = 997*997*dx*(r0+dx) / (1000*1000*r0 + 997*997*dx) 同时除以dx：
ex/dx = 997*997*(r0+dx) / (1000*1000*r0 + 997*997*dx) 由于ex是最终环回交易结束时我们的 tokenA 数量, dx 是我们 tokenA 的输入数量, 1-ex/dx 就是我们的手续费比例。
从上面的公式可知，最终环回交易的ex只跟输入dx和tokenA的reserve有关，而且，输入数量dx与tokenA reserve比值越高，最终得到的ex/dx 越接近1，也就是付出的手续费越少。
代码演算 测试代码如下：
Filename: loopbackSwap.js
const BigNumber = require('ethers').BigNumber const e18 = BigNumber.from('1000000000000000000') const getAmountOut = (amountIn, r0, r1) => { const amountInWithFee = amountIn.mul(997) , numerator = amountInWithFee.mul(r1) , denominator = r0.mul(1000).add(amountInWithFee); return numerator.div(denominator) } const getAmountBack = (amtIn, r0, r1, printable = false) => { const out = getAmountOut(amtIn, r0, r1) r0 = r0.add(amtIn) r1 = r1.sub(out) const dx = getAmountOut(out, r1, r0) if (printable) { console.info('swap x->y: out=%s r0=%s r1=%s backx=%s', out.toString(), r0.toString(), r1.toString(), dx.toString()) } return { amtInter: out, amtOut: dx } } function loopbackSwap() { const reserveA = BigNumber.from(1000000).mul(e18) , reserveB = BigNumber.from(2000000).mul(e18) , ratio = (multor) => reserveA.mul(multor).div(1000) let amts = [ 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 3000, 5000, 10000 ] for (let amt of amts) { let amtIn = ratio(amt) let { amtOut } = getAmountBack(amtIn, reserveA, reserveB) console.info('dx/reserve=%s amtOut/amtIn=%s', amt/1000, amtOut.mul(10000).div(amtIn).toNumber()/10000) } } loopbackSwap() run the scripts:
npx hardhat run loopbackSwap.js dx/reserve=0.001 amtOut/amtIn=0.994 dx/reserve=0.002 amtOut/amtIn=0.994 dx/reserve=0.005 amtOut/amtIn=0.994 dx/reserve=0.01 amtOut/amtIn=0.994 dx/reserve=0.02 amtOut/amtIn=0.9941 dx/reserve=0.05 amtOut/amtIn=0.9942 dx/reserve=0.1 amtOut/amtIn=0.9945 dx/reserve=0.2 amtOut/amtIn=0.995 dx/reserve=0.5 amtOut/amtIn=0.9959 dx/reserve=1 amtOut/amtIn=0.9969 dx/reserve=2 amtOut/amtIn=0.9979 dx/reserve=3 amtOut/amtIn=0.9984 dx/reserve=5 amtOut/amtIn=0.9989 dx/reserve=10 amtOut/amtIn=0.9994 从结果可以看出，当 dx/reserve 超过1后，手续费率极速降低，当dx/reserve=10，手续费仅为万分之6
由此，可以使用闪电贷，在较低的利率下，将大量资金从借贷池中借出，然后进行环回交易，在一些交易即挖矿的交易所中，可以通过这种方式降低挖矿手续费，套利获利。
实战 我们可以编写一个合约来执行我们的环回交易。
需要注意的是，我们不能直接将 uniswap router 的 path 参数设置为 [tokenA, tokenB, tokenA] 来进行环回交易，而必须分成两次swap, 首先是 [tokenA, tokenB]， 然后是 [tokenB, tokenA].
示例代码如下：
/// @dev swapLoopback swap tokenA to tokenB, then swap tokenB to tokenA /// @param _router uniswap-like router /// @param reward the reward token /// @param amountIn amount in /// @param amountOutMin just set to 0 /// @param path [tokenA, tokenB] function swapLoopback( address _router, // router address reward, // reward token uint amountIn, uint amountOutMin, address[] memory path ) public onlyOwner { address tokenIn = path[0]; uint tokenInitial = IERC20(tokenIn).balanceOf(address(this)); _approve(IERC20(tokenIn), address(_router)); // solhint-disable-next-line uint256 ts = block.timestamp + 60; uint[] memory amounts = IUniswapRouter(_router).swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), ts); path[0] = path[1]; path[1] = tokenIn; // console.log("amounts:", amounts[1]); _approve(IERC20(path[0]), address(_router)); amounts = IUniswapRouter(_router).swapExactTokensForTokens(amounts[1], amountOutMin, path, address(this), ts); // other arbitrage code with reward.. reward; }</content></entry><entry><title>元交易及其实现</title><url>https://www.tiege.dev/post/meta-transaction-and-implement/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag><tag>EIP-712</tag><tag>meta-transaction</tag></tags><content type="html"> 什么是元交易 简单来说，元交易(meta transaction)就是由第三方代理用户发送的交易。
元交易的流程如下：
用户构建交易参数，对交易参数签名 第三方将交易签名发送至 Relay/Forwarder 合约 Relay/Forwarder 合约验证用户的签名是否相符 Relay/Forwarder 调用最终的合约 普通的交易如下图所示:
元交易的如下图所示:
注： 图中的 Relayer 就是本文的 Forwarder 合约
元交易可以用来做什么 元交易大体有两个用途:
我们知道，去中心化的体验门槛很高，普通用户要玩去中心化，起码需要： a. 下载交易所，充币，认证，购买以太坊 b. 安装metamask，记住助记词，生吃地址； c. 交易所提币； d. 了解去中心化dapp, 理解原理, 使用dapp 上述任何一个步骤都非常麻烦，一整套流程走下来，半天就过去了
因此，使用元交易，可以让用户没有以太，就可以体验 dapp
安全 假如你有冷钱包，里面有很多钱，你不想让冷钱包直接触网，这时，你可以使用这种方式，让 Relayer/Forwarder 合约作为你的代理发送交易。
如何实现元交易 我们构建这样的一个数据结构:
struct ForwardRequest { // 用户地址 address from; // 用户要调用的合约地址 address to; // 交易发送的以太数量 uint256 value; // 设置的gas费, 可以不需要 uint256 gas; // Forwarder合约中记录的用户的nonce, 防止重放攻击 uint256 nonce; // 用户调用的函数和参数 bytes data; } 用户签名 待签名数据的构建基于 EIP-712, 如下:
/// @notice Returns a hash of the given data, prepared using EIP712 typed data hashing rules. /// @param from origin sender /// @param to contract to call /// @param value send ETH value /// @param nonce from's nonce /// @param data encodewithselector contract call params /// @return digest hash digest function getDigest( address from, address to, uint256 value, uint256 nonce, bytes memory data ) public view returns (bytes32 digest) { digest = _hashTypedDataV4( keccak256(abi.encode(_TYPE_HASH, from, to, value, nonce, keccak256(data)))); } 函数 _hashTypedDataV4 是根据 EIP-712 实现的, 代码如下:
function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) { return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash); } function _domainSeparatorV4() internal view returns (bytes32) { return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash()); } function _buildDomainSeparator( bytes32 typeHash, bytes32 nameHash, bytes32 versionHash ) private view returns (bytes32) { return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this))); } 其中，_EIP712NameHash _EIP712VersionHash 是合约创建时设置的
然后, 使用用户的私钥对上面算出来的 digest 签名:
import { utils } from 'ethers' const userkey = new utils.SigningKey(privateKey) , sig = userkey.signDigest(digest) , sigs = utils.joinSignature(sig) 合约验证签名合法性 验证签名的合法性基于两点:
ecrecover 从digest，签名中解出的地址与用户地址一致
nonce ForwardRequest.req 结构体中的 nonce 与合约中记录的nonce一致
验签代码如下:
using ECDSAUpgradeable for bytes32; function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) { bytes32 digest = getDigest(req.from, req.to, req.value, req.nonce, req.data); address signer = digest.recover(signature); return _nonces[req.from] == req.nonce &amp;&amp; signer == req.from; } msg.sender 的问题 当 Forwarder 合约最终调用 to 合约时，to 合约中使用 msg.sender 时, msg.sender 值为 Forwarder 合约地址。如果需要在 to 合约中使用用户地址，则需要做一些修改。
首先，Forwarder 合约调用 to 合约时，已经将用户的地址附加在调用参数的后面。to 合约的被调用函数并不需要知道这个参数的存在，因为 to 合约的函数取哪些参数，如何获取这些参数是在合约编译时，已经确定了, to 合约只是按照偏移量去 sload 数据. 在最后增加一个参数不会影响原来参数的获取，也不会像c/c++那样破坏堆栈。
Forwarder合约的执行:
(bool success, bytes memory returndata) = req.to.call{value: req.value}( abi.encodePacked(req.data, req.from) ); 这样，Forwarder 合约就把用户的地址传给了 to 合约，剩下的就交给 to 合约了。
然后，to 合约要怎么得到用户地址呢?
我们先来看看 openzeppelin 的 Context 合约:
abstract contract Context { function _msgSender() internal view virtual returns (address) { return msg.sender; } function _msgData() internal view virtual returns (bytes calldata) { return msg.data; } } 这是一个非常基础的合约，很多合约就是基于 Context 合约. 最开始看到这两个函数时，我非常迷惑, _msgSender() 就是简单的返回 msg.sender, 有什么作用呢？实际上，绝大部分时候，我们都是直接使用 msg.sender, 很少调用 _msgSender()。
在处理元交易时， _msgSender() 的作用就体现出来了, 我们可以重写 _msgSender 函数，来得到 用户地址，当然，前提是 to 合约需要配置 Forwarder 合约的地址。
在 to 合约中， 重写 _msgSender 函数代码如下：
address private _trustedForwarder; function isTrustedForwarder(address forwarder) public view virtual returns (bool) { return forwarder == _trustedForwarder; } function _msgSender() internal view virtual override(ContextUpgradeable) returns (address sender) { if (isTrustedForwarder(msg.sender)) { // The assembly code is more direct than the Solidity version using `abi.decode`. assembly { sender := shr(96, calldataload(sub(calldatasize(), 20))) } } else { return msg.sender; } } function _msgData() internal view virtual override(ContextUpgradeable) returns (bytes calldata) { if (isTrustedForwarder(msg.sender)) { return msg.data[:msg.data.length - 20]; } else { return msg.data; } } 这样, 就完成了对 to 合约的修改。 openzeppelin 的代码都是使用 _msgSender 来获取 msg.sender, 如果 to 合约继承了 openzeppelin 合约，那么继承的函数就直接支持了元交易。
此外，还有一种解决方式，就是在 to 合约中提供一个函数来设置用户的地址，Forwarder 调用 to 合约前，调用该函数设置用户地址；to合约执行时，从临时变量中读取用户地址; 执行完成后, Forwarder 合约在把地址重置。
显然这种方案没有第一种方案优雅，而且需要一个storage变量来存储用户地址，也增加了 gas 费用。
安全问题 重放攻击 例如，一个转账交易，如果没有检查，再次用同样的参数调用，就有可能再次转账。
解决的方式有很多种，一种是在 合约中为用户记录nonce值，每次交易自增nonce；另一种是记录交易hash，不允许重复的交易hash
样例代码 https://github.com/guotie/meta-tx
包含了使用, 部署，测试，Proxy 代理的实现。</content></entry><entry><title>AAVE源代码分析 -- AAVE 利率</title><url>https://www.tiege.dev/post/aave/aave-interest-model/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag></tags><content type="html"> 利率模型和风险控制是借贷协议的核心, 在AAVE中，利率的更新可以分为三个部分:
存币利率 活期借款利率 定期借款利率 至于风险控制，在后面的章节中，我们单独讨论。
ReserveData 结构体 ReserveData 是 AAVE 利率变动的核心数据结构。ReserveData 在 contracts\protocol\libraries\types\DataTypes.sol 文件中定义，相关代码如下：
// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties. struct ReserveData { // stores the reserve configuration // 各种配置, 就是一个 uint256, 不同的配置项使用不同为, 简单的 bitmask 算法 ReserveConfigurationMap configuration; // the liquidity index. Expressed in ray // 存币利率: aToken 与 token 的换算关系 uint128 liquidityIndex; // variable borrow index. Expressed in ray // 活期借款利率 uint128 variableBorrowIndex; // the current supply rate. Expressed in ray // 活期借款利率与定期借款利率的加权平均 uint128 currentLiquidityRate; // the current variable borrow rate. Expressed in ray // 活期借款利率 uint128 currentVariableBorrowRate; // the current stable borrow rate. Expressed in ray // 定期借款利率 uint128 currentStableBorrowRate; uint40 lastUpdateTimestamp; // tokens addresses address aTokenAddress; address stableDebtTokenAddress; address variableDebtTokenAddress; // address of the interest rate strategy address interestRateStrategyAddress; // the id of the reserve. Represents the position in the list of the active reserves uint8 id; } ReserveData 是借贷关系最核心的结构体, 每个市场上可以借贷的币种，都有一个对应的 ReserveData , 用来记录该币对的各种利率。
与利率相关的变量:
liquidityIndex: 存币利率 variableBorrowIndex: 活期借款利率 currentLiquidityRate: 流动率, 用于更新 liquidityIndex currentStableBorrowRate: 定期借款率 currentVariableBorrowRate: 活期借款率, 用于更新 variableBorrowIndex 两段式利率 利率的核心是供求关系。每当资金发生变化时，AAVE 都会自动调整利率. 利率的调整是基于供求关系，在 AAVE 或 Compound 中，反映资金供求关系的变量是资金利用率。资金利用率的定义是：
Utilisation = 总借款 / (总存款+总借款) 总借款 = 活期借款 + 定期借款 利率随供求关系变化的示意图：
这个图很清晰的说明了利率的变化:
当使用率不超过最佳使用率时, 利率 = 基本利率 + 使用率 * slope1-rate 当使用率超过最佳使用率时, 利率 = 基本利率 + slope1-rate + (使用率-最佳使用率) * slope2-rate 从图中可知, 当使用率超过最佳使用率时，利率上涨的速度非常快, 这促使借款人尽快归还借款，否则，就很有可能被清算。
liquidityIndex 这是指标是 token/atoken 的存币利率
主要用到的地方:
存币 deposit 将用户的token转入合约，mint aToken并转给用户.
将 token mint 为 atoken，换算关系为:
atoken 数量 = token 数量 / liquidityIndex 取回 withdraw 将用户的 aToken 转入合约并销毁, 将对应的 token 转给用户
token 数量 = atoken 数量 * liquidityIndex 由于 liquidityIndex 在不断增长, 由上面两个公式就可以算出用户的存币利息所得。
variableBorrowIndex 借款利率 活期借款 当用户借款时, 系统会给用户 mint 借款的代币, 用来记录用户的借款, 已经随时间变化产生的利息.
varDebtToken 数量 = token 数量 / variableBorrowIndex 活期还款 当用户还款时，需要还的数量通过以下公式计算:
token 数量 = varDebtToken 数量 * variableBorrowIndex 清算 清算是风控的核心，在风控章节详细讨论。
定期借款 定期借款与活期借款类似，但有所不同。由于使用定期借款的比例非常少, 这里暂时跳过对定期借款的分析
利率的计算过程 利率的计算主要在文件 contracts\protocol\lendingpool\DefaultReserveInterestRateStrategy.sol 中，函数名为 calculateInterestRates.
计算的大概过程是:
总借款 = 活期借款 + 定期借款 资金利用率 = 总借款 / (总存款+总借款) 计算活期利率和定期利率。这两个利率都是两段式计算, 每一段的变化都是线性的。 a. 活期利率 = 基本活期利率 + 资金利用率 * slope1活期 (如果超过第一段, 还需要计算第二段的利率) b. 定期利率 = 基本定期利率 + 资金利用率 * slope1定期 加权平均借款利率 = (活期借款活期利率 + 定期借款平均定期利率) / 总借款， 这里的平均定期利率是函数入参，不再这里计算 currentLiquidityRate = (加权平均借款利率/总借款) * 资金利用率 * (1-储备率) 可以看到, currentLiquidityRate 的计算最复杂, 那么这个变量的用途是什么呢? 答案是用来计算存款利率(liquidityIndex)
对于利率的相关代码的分析，见: AAVE 利率代码解析
AAVE系列文章:
AAVE借贷协议简介 AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 清算; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 测试及部署;</content></entry><entry><title>AAVE源代码分析 -- AAVE代码整体架构</title><url>https://www.tiege.dev/post/aave/how-aave-interest-update/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag><tag>architecture</tag></tags><content type="html"> AAVE 整体架构 AAVE是一个借贷协议, 因此, 核心是围绕着存款，借款，还款，清算这四大环节展开的。我认为, AAVE 之所以看起来很复杂, 非常重要的一点是因为定期借款的存在, 极大的提高了利率模型的复杂度, 否则, AAVE 应该更加清晰。
AAVE 架构图如下:
目录结构及文件 合约主要在 contracts 目录下, contracts 目录结构如下：
├─adapters // 外部合约适配层 │ └─interfaces ├─dependencies // 一些基础库, 大部分基于 openzeppelin 修改 │ └─openzeppelin │ ├─contracts │ └─upgradeability ├─deployments // 部署相关 ├─flashloan // 闪电贷 │ ├─base │ └─interfaces ├─interfaces // 接口定义 ├─misc │ └─interfaces ├─mocks // 测试相关 │ ├─attacks │ ├─dependencies │ │ └─weth │ ├─flashloan │ ├─oracle │ │ └─CLAggregators │ ├─swap │ ├─tokens │ └─upgradeability └─protocol // 核心实现, 核心代码全部在这个目录下 ├─configuration ├─lendingpool ├─libraries │ ├─aave-upgradeability │ ├─configuration │ ├─helpers │ ├─logic │ ├─math │ └─types └─tokenization └─base 结合 AAVE 的部署代码, 算上Mock合约, AAVE 大概有 30 个合约:
LendingPoolAddressesProvider = 'LendingPoolAddressesProvider', LendingPoolAddressesProviderRegistry = 'LendingPoolAddressesProviderRegistry', LendingPoolParametersProvider = 'LendingPoolParametersProvider', LendingPoolConfigurator = 'LendingPoolConfigurator', ValidationLogic = 'ValidationLogic', ReserveLogic = 'ReserveLogic', GenericLogic = 'GenericLogic', LendingPool = 'LendingPool', PriceOracle = 'PriceOracle', Proxy = 'Proxy', LendingRateOracle = 'LendingRateOracle', AaveOracle = 'AaveOracle', DefaultReserveInterestRateStrategy = 'DefaultReserveInterestRateStrategy', LendingPoolCollateralManager = 'LendingPoolCollateralManager', InitializableAdminUpgradeabilityProxy = 'InitializableAdminUpgradeabilityProxy', WalletBalanceProvider = 'WalletBalanceProvider', AToken = 'AToken', DelegationAwareAToken = 'DelegationAwareAToken', AaveProtocolDataProvider = 'AaveProtocolDataProvider', StableDebtToken = 'StableDebtToken', VariableDebtToken = 'VariableDebtToken', FeeProvider = 'FeeProvider', TokenDistributor = 'TokenDistributor', StableAndVariableTokensHelper = 'StableAndVariableTokensHelper', ATokensAndRatesHelper = 'ATokensAndRatesHelper', UiPoolDataProvider = 'UiPoolDataProvider', WETHGateway = 'WETHGateway', UniswapLiquiditySwapAdapter = 'UniswapLiquiditySwapAdapter', UniswapRepayAdapter = 'UniswapRepayAdapter', FlashLiquidationAdapter = 'FlashLiquidationAdapter', 以下是 Mock 合约 MockAToken = 'MockAToken', MockAggregator = 'MockAggregator', WETHMocked = 'WETHMocked', SelfdestructTransferMock = 'SelfdestructTransferMock', MockStableDebtToken = 'MockStableDebtToken', MockVariableDebtToken = 'MockVariableDebtToken', MockFlashLoanReceiver = 'MockFlashLoanReceiver', MockUniswapV2Router02 = 'MockUniswapV2Router02', MintableERC20 = 'MintableERC20', // mock MintableDelegationERC20 = 'MintableDelegationERC20', // mock 借贷核心 借贷核心包括:
利率的计算 AAVE 将利率的计算移到了三个library中，路径为 contracts\protocol\libraries\logic\, 主要是: GenericLogic.sol 计算用户 account
ReserveLogic.sol 核心中的核心, 各种利率的计算
ValidationLogic.sol 这个库主要是各种安全校验, 存款校验, 借款校验, 还款校验, 清算校验, 转账校验, 活期定期转换校验等等
LendPool LendPool 是借贷动作的入口, 包括存款，借款，还款，清算等动作。
LendingPoolCollateralManager 主要负责完成清算
DefaultReserveInterestRateStrategy 利率变化的策略：calculateInterestRates
tokenization AAVE 中用户的存款，借款都是以 token 的方式记录。Compound 中，只有存款是以 token 的方式记录，借款并没有 tokenization. 其实, 我觉得借款并没有 tokenization 的必要。
AToken 存款凭证，类似于 Compound 中的 cToken。当用户存入 token 时，AAVE 给用户 mint 对应的 aToken
DelegationAwareAToken AToken 的代理
StableDebtToken 定期借款 token, 用于记录用户的定期借款
VariableDebtToken 活期借款 token, 用于记录用户的活期借款
市场及Provider、配置管理 LendingPoolAddressesProvider LendingPoolAddressesProviderRegistry LendingPoolParametersProvider LendingPoolConfigurator Oracle 辅助合约 AaveProtocolDataProvider 把一些整合并计算好, 方便前端调用
UiPoolDataProvider 把一些整合并计算好, 方便前端调用
StableAndVariableTokensHelper 辅助管理合约, 同时设置多个 asset 的 borrowRate
WalletBalanceProvider 查询 balance 信息, 并不是很必要, 实际上可以通过 multicall 来完成这样的功能。当然, 这样可以更有针对性的获取数据, 速度也更快
ATokensAndRatesHelper 辅助管理合约, 设置配置信息
adapter 主要是 uniswap adapter，包括以下几个合约:
UniswapLiquiditySwapAdapter UniswapRepayAdapter FlashLiquidationAdapter Proxy LendPool 的 proxy 这么多合约确实让人眼花缭乱，然而，我们可以先从核心开始分析，也就是利率模型和风险控制相关的合约，大约7-8个合约。</content></entry><entry><title>About</title><url>https://www.tiege.dev/about/</url><categories/><tags/><content type="html"> 铁叔 老年程序员，以代码为生计，正在为世界的去中心化事业而奋斗。
Older programmers, who coding for a living, and fighting for a decentralize world.
projects technology Rust golang C/C++ smart contract &amp; solidity java/Spring frontend</content></entry><entry><title>solidity函数selector的计算</title><url>https://www.tiege.dev/post/evm-selector/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag></tags><content type="html"> solidity 中有函数选择器(selector)的概念.
什么是 selector 在 solidity 中，所有 public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。
evm 函数选择器是一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节(高位在左的大端序) (译注：这里的 高位在左的大端序，指最高位字节存储在最低位地址上的一种串行化编码方式，即高位字节在左)。 这种签名被定义为基础原型的规范表达，基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。
简单来说，就是函数原型的 sha-3 hash值。
selector 有什么用途 在 以太坊Ethereum 生态系统中， 应用二进制接口 Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。
我们假定合约函数的接口都是强类型的，且在编译时是可知的和静态的；不提供自我检查机制。我们假定在编译时，所有合约要调用的其他合约接口定义都是可用的。
这份手册并不针对那些动态合约接口或者仅在运行时才可获知的合约接口。如果这种场景变得很重要，你可以使用 以太坊Ethereum 生态系统中其他更合适的基础设施来处理它们。
官方说明： https://docs.soliditylang.org/en/v0.8.7/abi-spec.html
如何计算 selector selector 可以通过两种方式获取，一种是查询 function.selector，另一种就是自己计算。
写个简单的测试合约，就能秒懂。
// SPDX-License-Identifier: MIT pragma solidity >=0.6.0; pragma experimental ABIEncoderV2; interface IABI { function initialize(address a, address b, address c, address d) external; } contract ABI { function initiliaze(address a, address b, address c, address d) public { } function getCodeByKeccak() public pure returns (bytes4) { return bytes4(keccak256(bytes("initialize(address,address,address,address)"))); } function getCodeBySelector() public view returns (bytes4) { IABI addr = IABI(address(this)); return addr.initialize.selector; } } 当计算函数选择器(selector)时，计算传入bytes数组有两点需要注意：
函数参数只有类型，没有名称，例如上例中的 initialize(address,address,address,address) 参数中间没有空格！参数中间没有空格！参数中间没有空格！ 如果要在链下计算，可以通过 ethers 提供的工具函数 id，代码如下：
import { id } from 'ethers/lib/utils'; const hash = id('initialize(address,address,address,address)') , selector = hash.slice(0, 10) selector 重复怎么办？ 如果一个合约中有重复的 selector，编译器会报错。
如果函数原型的参数是自定义的结构体, 怎么办? 如果是结构体, 在计算 selector 时, 将结构体展开为 tuple 来计算。例如：
struct Reward { address ctoken; address underlying; uint256 amount; uint256 debt; uint256 pending; address benefit; address owner; address[] path; }, function calcReward(Reword r, address to) returns (uint256); 在计算函数 calcReward 的selector时, 实际上是计算
calcReward((address,address,uint256,uint256,uint256,address,address,address[]),address) 这个字符串的 id
对于比较复杂的情况，我建议使用 ethers 库的 Interface 来计算函数的 selector, 链接: https://docs.ethers.io/v5/api/utils/abi/interface/
根据ABI创建 Interface
使用 Interface.getSighash() 获取函数的 selector
使用 Interface.getFunction('xxx').format('sighash') 获取计算 selector 的函数签名
完整的示例如下:
const { expect } = require("chai"); const { ethers } = require("hardhat"); describe("ABI selector", function() { it('selector', async () => { const iface = new ethers.utils.Interface([ // Constructor "constructor(string symbol, string name)", // State mutating method "function transferFrom(address from, address to, uint amount)", // State mutating method, which is payable "function mint(uint amount) payable", // Constant method (i.e. "view" or "pure") "function balanceOf(address owner) view returns (uint)", // An Event "event Transfer(address indexed from, address indexed to, uint256 amount)", // A Custom Solidity Error "error AccountLocked(address owner, uint256 balance)", // Examples with structured types "function addUser(tuple(string name, address addr) user) returns (uint id)", "function addUsers(tuple(string name, address addr)[] user) returns (uint[] id)", "function getUser(uint id) view returns (tuple(string name, address addr) user)" ]); console.log('addUsers getSighash: %s', iface.getSighash('addUsers')) let addUserFormat = iface.getFunction('addUsers').format(ethers.utils.FormatTypes.getSighash) console.log('addUsers format: %s', addUserFormat) console.log('addUsers selector:', ethers.utils.id(addUserFormat).slice(0, 10)) }) })</content></entry><entry><title>AAVE源代码分析 -- AAVE借贷协议简介</title><url>https://www.tiege.dev/post/aave/brief-introduction-to-aave-protocol/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag></tags><content type="html"> DEFI 上最初的应用就是借贷应用。借贷，顾名思义，是一个允许用户借贷代币的智能合约，它与银行类似，存款人把钱存入到借贷应用中(更具体的说，就是某个智能合约)，借贷应用把你的钱借给借款人，并随着时间的推移赚取利息。当借款人资不抵债时，会触发清算，任何人都可以参与清算，清算成功时清算人将获取一定比例的清算奖励。同时，借贷应用的清算系统能够确保借贷系统的稳定，进而保证存款人的利益。
DEFI 借贷在以下几个方面与银行不同:
利息的计算; a. DEFI 借贷利息的计算是从你存入的块开始计算，到你取出的块停止计算； b. DEFI 借贷的利息浮动范围很广，跟资金利用率(可以简单理解为 贷出资金/总借贷金额)息息相关，大多数借贷系统都设置比例，当资金利用率超过该比例时，利息会上涨的非常快，且利息很高，因此，这对于借款人来说，是非常不利的; c. 所有借款都必须有超额抵押，不存在信用贷款的概念;
清算 a. DEFI 借贷的所有存入，借出都是公开透明的; b. DEFI 借贷的清算标准是固定的; c. 任何人都可以进行清算，并且，清算人可以获取丰厚的清算奖励，通常是清算金额10% d. 由于清算奖励的巨大诱惑，且公开透明的数据，可以保证清算工作的稳定运行；
闪电贷 闪电贷是 AAVE 的一个巨大创新，所谓闪电贷，不是银行的闪电贷，这里的闪电贷是指，在一个区块交易中，同时完成先贷后还的操作。举个例子，现在有一个套利机会，但是你有没有资金，这时候，你就可以使用闪电贷，借出资产，完成套利，归还资金和利息，剩下的就是你的套利收益。
闪电贷也被很多人用于合约攻击，获取更大的收益。最近发生的很多起攻击事件，都是使用闪电贷的资金作为来源。
存款标的。 你可以将很多标的存入银行，由银行来对你的标的进行资产评估；而 DEFI 借贷只能存入部分 token, 因为 token 有公开定价, 而资产评估必须要链下评估，难以在链上完成。 DEFI 的借贷经历了三个发展阶段, 第一阶段的代表作是 MakerDAO, 第二阶段的代表作是 Compound, 第三阶段的代表作是 AAVE.
毫无疑问, Makerdao 是开创者; Compound 重新设计了利率模型, 可以说此后所有的借贷模型都是在 Compound 的基础之上发展而来, 从而奠定了 Compound 的江湖地位; AAVE 则是集大成者, AAVE 的借贷模型与 Compound 相同, 与Compound, MakerDAO 相比, AAVE 有以下特点:
AAVE 最大的创新就是引入了 闪电贷 (flashloan) 这个大杀器, 从此以后, 只有在链上有机会套利或者攻击, 你根本不用担心资金问题; 闪电贷也是链上借贷的独特优势, 在传统的金融行业中, 根本不存在这样的功能; AAVE 还有固定利率功能。我们知道, Compound 的利率是在不断的变化的，跟资金使用率息息相关, 当资金使用率突然升高时，借款利率会急速上升，对于长期资金使用者来说，这是无法承受的，AAVE引入了固定利率，从而解决了有长期资金需求借款人的借贷问题； AAVE 的代码比 Compound 写的更好, 更加工整, 框架清晰, 可读性, 可维护性都比 Compound 高几个档次 AAVE 更加安全。AAVE 的代码质量更高，模块化、结构化更好，测试更加充分，安全性更高。前几天 Cream protocol 发生的被攻击事件，让 Cream 损失了几千万美元。如果 Cream 当初是 fork 了 AAVE 的代码，这个攻击就无法进行。原理后面再详细分析 与swap市场 uniswap 一家独大不同，目前，借贷市场还处于三国鼎立的阶段，MakerDao, Compound, AAVE 各有优势, AAVE 在存款数量上有一定优势, Compound用户数最多，群众基础较好; MakerDao 锁仓金额较多；当然，这三者各有所长，差距不是非常明显, 其他模仿者就和这三大巨头的差距比较大，在没有大的创新的情况下，很难挑战这三大巨头。
由于 AAVE 比 Compound 代码更复杂，因此，目前 bsc、heco 这些链上的借贷市场几乎都是 fork Compound 代码，同时，由于这些团队追求快速上线，也没有对 Compound 进行深入研究，导致最终上线的产品不敢改也不能改，最多的就是把 cToken 改成各种 xToken，反正圈钱发币为主，不影响使用。
从学习的角度看，AAVE 代码质量非常优秀，比 Compound 高出好几个档次, AAVE v1版本就已经非常规范，v2版本更是青出于蓝而胜于蓝，从各个方面来看，都堪称典范:
结构非常清晰，interface, library, 实现，核心代码，适配层分门别类，各司其职； 完整的测试代码； 完整的部署代码； 完善的官方文档，白皮书等； 完善的周边 sdk，代码示例； 统一的代码风格，统一的注释风格，所有函数都有注释； 完善的代码检查，lint； Library 的应用真是炉火纯青 WETHGateway 的引入，统一了 ETH 和 Token, 这一点我觉得比 uniswap 做的好，uniswap 的 Router 合约有很多专门为 ETH 服务的接口，如果改成这种方式，会更加清晰； 教科书级别 Proxy 应用, 当然, 目前 openzeppelin 的代理是更加通用的解决方案 唯一能与之相提并论的是 uniswap, 当然, uniswap 把前端界面也开源了， 而 AAVE 并没有开源前端界面, 这是 AAVE 不如 uniswap 的地方。
我们将推出有一系列的文章来讲解 AAVE 的代码: 0. AAVE借贷协议简介
AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 风险控制; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 部署;</content></entry><entry><title>libuv与TCP Keepalive</title><url>https://www.tiege.dev/post/libuv-and-tcp-keepalive/</url><categories><category>c/c++</category></categories><tags><tag>libuv</tag><tag>tcp</tag><tag>TCP Keepalive</tag><tag>linux</tag></tags><content type="html"> libuv 与 TCP Keepalive 关于 keepalive 这里的keepalive与HTTP的keepalive不同，这里的keepalive是TCP层的keepalive，用处是当两台机器之间通信时，中间网络出现故障，这时，两端并无法感知网络故障这个事件，无法及时发现网络故障。
HTTP的keepalive是指，一个请求在请求头部增加一个keep alive的行，这时，服务端传输完成后，不会关闭这个TCP连接，还可以继续下次HTTP请求，提高了效率。
Linux内核关于TCP keepalive的说明在这里： http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html
其中：
tcp_keepalive_time the interval between the last data packet sent (simple ACKs are not considered data) and the first keepalive probe; after the connection is marked to need keepalive, this counter is not used any further tcp_keepalive_intvl the interval between subsequential keepalive probes, regardless of what the connection has exchanged in the meantime tcp_keepalive_probes the number of unacknowledged probes to send before considering the connection dead and notifying the application layer 大致翻译一下就是
tcp_keepalive_time 当一台机器在 N 秒内，还没有收到对方的任何数据时，开始 keepalive 探测对方是否正常 tcp_keepalive_intvl keepalive报文发送的间隔，单位秒 tcp_keepalive_probes keepalive报文探测次数 也就是说，在 tcp_keepalive_time 秒内仍未收到对端数据时，开始发起 keepalive 探测，每隔 tcp_keepalive_intvl 发送一个探测报文，当 发送 tcp_keepalive_probes 探测报文，对方仍未响应时，关闭连接。
在Linux下，可以通过以下方式查看系统的keepalive配置：
[root@localhost ~]# cat /proc/sys/net/ipv4/ 1800 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_probes 9 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_intvl 75 keepalive 接口 设置一个套接字的keepalive的方法如下：
1. enable keepalive int on = 1; if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) { // log return -1; } 2. 设置 tcp_keepalive_time int idle = 10; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(int)) &lt; 0) { // log return -1; } 3. 设置 tcp_keepalive_probes int probes = 4; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;probes, sizeof(int)) &lt; 0) { // log return -1; } 4. 设置 tcp_keepalive_intvl int intvl = 1; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;intvl, sizeof(int)) &lt; 0) { // log return -1; } libuv 的 keepalive libuv提供的接口只能设置上面的两个：
enable keepalive 设置 tcp_keepalive_time libuv提供的接口为 uv_tcp_keepalive, 函数原型如下：
int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) Enable / disable TCP keep-alive. delay is the initial delay in seconds, ignored when enable is zero. 该函数的实现代码如下：
int uv__tcp_keepalive(int fd, int on, unsigned int delay) { if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) return -errno; #ifdef TCP_KEEPIDLE if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;delay, sizeof(delay))) return -errno; #endif /* Solaris/SmartOS, if you don't support keep-alive, * then don't advertise it in your system headers... */ /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ #if defined(TCP_KEEPALIVE) &amp;&amp; !defined(__sun) if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &amp;delay, sizeof(delay))) return -errno; #endif return 0; } int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) { int err; if (uv__stream_fd(handle) != -1) { err =uv__tcp_keepalive(uv__stream_fd(handle), on, delay); if (err) return err; } if (on) handle->flags |= UV_TCP_KEEPALIVE; else handle->flags &amp;= ~UV_TCP_KEEPALIVE; /* TODO Store delay if uv__stream_fd(handle) == -1 but don't want to enlarge * uv_tcp_t with an int that's almost never used... */ return 0; } 从上面的代码可以看出，当 uv__stream_fd(handle) 不成功时，仅仅设置该连接的flags位，实际上并没有用到delay这个参数。也就是说，只有当连接已经成功建立时，才能设置 tcp_keepalive_time，如果连接还没有建立成功，则这个值根本没有设置。
如果要设置后面两个数值的话，需要自己实现, 示例代码如下：
// // 设置 keepalive 相关的2个参数 // probes: 对应内核 tcp_keepalive_probes, 发送多少次keepalive报文还未收到回应时, close该连接 // intvl: 对应内核 tcp_keepalive_intvl, 发送keepalive报文的间隔时间 // idle: 对应内核 tcp_keepalive_time int set_keep_alive(const uv_handle_t* handle, int probes, int intvl, int idle) { int ret; uv_os_fd_t fd; ret = uv_fileno(handle, &amp;fd); if (ret &lt; 0) { return ret; } if (idle > 0) { if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(idle))) return -1; } // 设置 tcp_keepalive_intvl if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (const void *) &amp;intvl, sizeof(int)) &lt; 0 ) { return -1; } // 设置 tcp_keepalive_probes if ( setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (const void *) &amp;probes, sizeof(int)) &lt; 0) { return -1; } return 0; } 这个函数只能在连接建立成功后调用，因为只有连接建立成功才有fd，即uv_fileno才会返回成功。</content></entry><entry><title/><url>https://www.tiege.dev/post/1inch/how-does-1inch-find-best-swap-path/</url><categories/><tags/><content type="html"/></entry><entry><title/><url>https://www.tiege.dev/post/futures-perps/a-great-sheet-of-perp-protocols/</url><categories/><tags/><content type="html"/></entry></search>