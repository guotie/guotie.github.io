<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>下一代撮合引擎 -- 基于消息驱动的并行撮合引擎</title><url>https://www.tiege.dev/post/next-generation-matching-engine-parallel-matching-engine-base-on-message/</url><categories><category>Defi</category><category>Matching-engine</category></categories><tags><tag>Matching-engine</tag><tag>Matching</tag><tag>撮合</tag><tag>撮合引擎</tag><tag>并行撮合</tag><tag>kafka</tag><tag>消息队列</tag></tags><content type="html"> 现有撮合系统的容灾方案 复杂度高 脆弱性 耦合高 难以测试 难以定位问题 难以扩展 基于消息驱动的并行撮合 这里提出一种并行撮合的方式，首先，什么是 并行撮合 ?
并行撮合是指，多台机器对订单同时撮合，不是1主N从的方式，也不是 Round-Robin，而是 同时撮合.
并行撮合的原理是，如果我们把撮合引擎看做一个状态机，输入是 kafka 消息，输出是下一个状态。该状态机依赖于上一个状态和输入消息，用数学表达如下:
f(0) = 初始状态 f(t) = f(m(t), f(t-1)) f(t) 是消息 t 对应的状态; m(t) 是消息 t 对于撮合引擎而言，当系统载入初始数据后，撮合过程不再依赖环境变量，也不依赖任何随机数据，对于数据的处理，结果是完全确定的。因此，从理论上说，撮合系统，在相同的初始条件，相同的输入，必然产生相同的输出，这就是并行撮合的原理。也就是说，我们不需要像传统的做法那样，在多台撮合引擎之间通过多播协议来同步数据，而是靠相同的初始条件，相同的输入数据，相同的处理流程，以及定时检查，来保证在 同一消息点 上，各个撮合引擎之间的数据的一致性。
Ok，撮合引擎之间的数据一致性可以保证了，这只是整个系统容灾的一小部分，对于整个系统来说，每个环节都是需要确保正确，可容灾。
对于持久存储，例如redis和数据库，我们通过 kafka sequece id 来保证不可重入。
首先，对于一个订单生命周期的每一次变动，都是由kafka消息触发的。例如，订单的创建，由用户发送买入或卖出请求触发；订单的撮合，是由新订单的进入触发；订单的结束，是撮合的结果，自然也是新的订单触发； 其次，用户的资产变动，也可以认为是由消息触发。用户的资产变动，主要由以下几个方面:
充币 提币 OTC 各种交易 最后，从更大的层面来说，不单是订单，资产，我们可以将所有的输入，都抽象为消息，然后，整个系统的任何变动，都是由基于消息触发。
问题来了，如何实现，如何保证正确性，如何保证一致性，如何容灾？
如何实现 先是架构图： kafka 是我们的核心单元，kafka的每一条消息都有一个sequence id，这是一个64位自增的正整数。我们依赖 kafka 的 sequence id 来保证数据的一致性。具体来讲，对于订单数据，我们保存在三个地方，撮合引擎的内存中，redis中，数据库中。三者之间的数据一致，也就是说，在同一个 sequence
撮合引擎的数据一致性
如何保证一致性 理论上，每台撮合引擎初始数据一致，处理相同的消息，并且是按照相同的顺序处理，因此，在同一个消息点上，所有撮合引擎的内存中的orderbook是应该完全一致的。
其他机器启动时如何同步数据 如何容灾 因为多台机器同时撮合, 因此，该方案本身天生就是容灾的!
定期检查机制 通过 kafka 发送 检查指令 消息, 撮合引擎收到该消息后, 对本引擎的交易对的 orderbook 做 hash 运算, 然后将结果发出来对比，必须保证多台撮合引擎的 hash 值完全一致, 否则就需要定位排查为何 hash 值不一致。
实现细节 redis 高可用 redis 事务 orderbook 在 redis 中的存储 数据库结构及订单存储 撮合引起启动时初始数据，及同步验证 启动
异步 哪些可以异步，哪些必须顺序执行?
故障定位，故障解决 性能 优势 多台撮合引擎解耦 多台撮合引擎数据时刻一致 易于升级，易于测试 实时验证, 实时监测 缺点 消息量增加 1/N 倍 (架构1增加N倍，架构2增加1倍)
redis 写入次数增加 N 倍</content></entry><entry><title>元交易及其实现</title><url>https://www.tiege.dev/post/meta-transaction-and-implement/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag><tag>EIP-712</tag><tag>meta-transaction</tag></tags><content type="html"> 什么是元交易 简单来说，元交易(meta transaction)就是由第三方代理用户发送的交易。
元交易的流程如下：
用户构建交易参数，对交易参数签名 第三方将交易签名发送至 Relay/Forwarder 合约 Relay/Forwarder 合约验证用户的签名是否相符 Relay/Forwarder 调用最终的合约 普通的交易如下图所示:
元交易的如下图所示:
注： 图中的 Relayer 就是本文的 Forwarder 合约
元交易可以用来做什么 元交易大体有两个用途:
我们知道，去中心化的体验门槛很高，普通用户要玩去中心化，起码需要： a. 下载交易所，充币，认证，购买以太坊 b. 安装metamask，记住助记词，生吃地址； c. 交易所提币； d. 了解去中心化dapp, 理解原理, 使用dapp 上述任何一个步骤都非常麻烦，一整套流程走下来，半天就过去了
因此，使用元交易，可以让用户没有以太，就可以体验 dapp
安全 假如你有冷钱包，里面有很多钱，你不想让冷钱包直接触网，这时，你可以使用这种方式，让 Relayer/Forwarder 合约作为你的代理发送交易。
如何实现元交易 我们构建这样的一个数据结构:
struct ForwardRequest { // 用户地址 address from; // 用户要调用的合约地址 address to; // 交易发送的以太数量 uint256 value; // 设置的gas费, 可以不需要 uint256 gas; // Forwarder合约中记录的用户的nonce, 防止重放攻击 uint256 nonce; // 用户调用的函数和参数 bytes data; } 用户签名 待签名数据的构建基于 EIP-712, 如下:
/// @notice Returns a hash of the given data, prepared using EIP712 typed data hashing rules. /// @param from origin sender /// @param to contract to call /// @param value send ETH value /// @param nonce from's nonce /// @param data encodewithselector contract call params /// @return digest hash digest function getDigest( address from, address to, uint256 value, uint256 nonce, bytes memory data ) public view returns (bytes32 digest) { digest = _hashTypedDataV4( keccak256(abi.encode(_TYPE_HASH, from, to, value, nonce, keccak256(data)))); } 函数 _hashTypedDataV4 是根据 EIP-712 实现的, 代码如下:
function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) { return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash); } function _domainSeparatorV4() internal view returns (bytes32) { return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash()); } function _buildDomainSeparator( bytes32 typeHash, bytes32 nameHash, bytes32 versionHash ) private view returns (bytes32) { return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this))); } 其中，_EIP712NameHash _EIP712VersionHash 是合约创建时设置的
然后, 使用用户的私钥对上面算出来的 digest 签名:
import { utils } from 'ethers' const userkey = new utils.SigningKey(privateKey) , sig = userkey.signDigest(digest) , sigs = utils.joinSignature(sig) 合约验证签名合法性 验证签名的合法性基于两点:
ecrecover 从digest，签名中解出的地址与用户地址一致
nonce ForwardRequest.req 结构体中的 nonce 与合约中记录的nonce一致
验签代码如下:
using ECDSAUpgradeable for bytes32; function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) { bytes32 digest = getDigest(req.from, req.to, req.value, req.nonce, req.data); address signer = digest.recover(signature); return _nonces[req.from] == req.nonce &amp;&amp; signer == req.from; } msg.sender 的问题 当 Forwarder 合约最终调用 to 合约时，to 合约中使用 msg.sender 时, msg.sender 值为 Forwarder 合约地址。如果需要在 to 合约中使用用户地址，则需要做一些修改。
首先，Forwarder 合约调用 to 合约时，已经将用户的地址附加在调用参数的后面。to 合约的被调用函数并不需要知道这个参数的存在，因为 to 合约的函数取哪些参数，如何获取这些参数是在合约编译时，已经确定了, to 合约只是按照偏移量去 sload 数据. 在最后增加一个参数不会影响原来参数的获取，也不会像c/c++那样破坏堆栈。
Forwarder合约的执行:
(bool success, bytes memory returndata) = req.to.call{value: req.value}( abi.encodePacked(req.data, req.from) ); 这样，Forwarder 合约就把用户的地址传给了 to 合约，剩下的就交给 to 合约了。
然后，to 合约要怎么得到用户地址呢?
我们先来看看 openzeppelin 的 Context 合约:
abstract contract Context { function _msgSender() internal view virtual returns (address) { return msg.sender; } function _msgData() internal view virtual returns (bytes calldata) { return msg.data; } } 这是一个非常基础的合约，很多合约就是基于 Context 合约. 最开始看到这两个函数时，我非常迷惑, _msgSender() 就是简单的返回 msg.sender, 有什么作用呢？实际上，绝大部分时候，我们都是直接使用 msg.sender, 很少调用 _msgSender()。
在处理元交易时， _msgSender() 的作用就体现出来了, 我们可以重写 _msgSender 函数，来得到 用户地址，当然，前提是 to 合约需要配置 Forwarder 合约的地址。
在 to 合约中， 重写 _msgSender 函数代码如下：
address private _trustedForwarder; function isTrustedForwarder(address forwarder) public view virtual returns (bool) { return forwarder == _trustedForwarder; } function _msgSender() internal view virtual override(ContextUpgradeable) returns (address sender) { if (isTrustedForwarder(msg.sender)) { // The assembly code is more direct than the Solidity version using `abi.decode`. assembly { sender := shr(96, calldataload(sub(calldatasize(), 20))) } } else { return msg.sender; } } function _msgData() internal view virtual override(ContextUpgradeable) returns (bytes calldata) { if (isTrustedForwarder(msg.sender)) { return msg.data[:msg.data.length - 20]; } else { return msg.data; } } 这样, 就完成了对 to 合约的修改。 openzeppelin 的代码都是使用 _msgSender 来获取 msg.sender, 如果 to 合约继承了 openzeppelin 合约，那么继承的函数就直接支持了元交易。
此外，还有一种解决方式，就是在 to 合约中提供一个函数来设置用户的地址，Forwarder 调用 to 合约前，调用该函数设置用户地址；to合约执行时，从临时变量中读取用户地址; 执行完成后, Forwarder 合约在把地址重置。
显然这种方案没有第一种方案优雅，而且需要一个storage变量来存储用户地址，也增加了 gas 费用。
安全问题 重放攻击 例如，一个转账交易，如果没有检查，再次用同样的参数调用，就有可能再次转账。
解决的方式有很多种，一种是在 合约中为用户记录nonce值，每次交易自增nonce；另一种是记录交易hash，不允许重复的交易hash
样例代码 https://github.com/guotie/meta-tx
包含了使用, 部署，测试，Proxy 代理的实现。</content></entry><entry><title>AAVE源代码分析 -- AAVE 利率</title><url>https://www.tiege.dev/post/aave/aave-interest-model/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag></tags><content type="html"> 利率模型和风险控制是借贷协议的核心, 在AAVE中，利率的更新可以分为三个部分:
存币利率 活期借款利率 定期借款利率 至于风险控制，在后面的章节中，我们单独讨论。
ReserveData 结构体 ReserveData 是 AAVE 利率变动的核心数据结构。ReserveData 在 contracts\protocol\libraries\types\DataTypes.sol 文件中定义，相关代码如下：
// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties. struct ReserveData { // stores the reserve configuration // 各种配置, 就是一个 uint256, 不同的配置项使用不同为, 简单的 bitmask 算法 ReserveConfigurationMap configuration; // the liquidity index. Expressed in ray // 存币利率: aToken 与 token 的换算关系 uint128 liquidityIndex; // variable borrow index. Expressed in ray // 活期借款利率 uint128 variableBorrowIndex; // the current supply rate. Expressed in ray // 活期借款利率与定期借款利率的加权平均 uint128 currentLiquidityRate; // the current variable borrow rate. Expressed in ray // 活期借款利率 uint128 currentVariableBorrowRate; // the current stable borrow rate. Expressed in ray // 定期借款利率 uint128 currentStableBorrowRate; uint40 lastUpdateTimestamp; // tokens addresses address aTokenAddress; address stableDebtTokenAddress; address variableDebtTokenAddress; // address of the interest rate strategy address interestRateStrategyAddress; // the id of the reserve. Represents the position in the list of the active reserves uint8 id; } ReserveData 是借贷关系最核心的结构体, 每个市场上可以借贷的币种，都有一个对应的 ReserveData , 用来记录该币对的各种利率。
与利率相关的变量:
liquidityIndex: 存币利率 variableBorrowIndex: 活期借款利率 currentLiquidityRate: 流动率, 用于更新 liquidityIndex currentStableBorrowRate: 定期借款率 currentVariableBorrowRate: 活期借款率, 用于更新 variableBorrowIndex 两段式利率 利率的核心是供求关系。每当资金发生变化时，AAVE 都会自动调整利率. 利率的调整是基于供求关系，在 AAVE 或 Compound 中，反映资金供求关系的变量是资金利用率。资金利用率的定义是：
Utilisation = 总借款 / (总存款+总借款) 总借款 = 活期借款 + 定期借款 利率随供求关系变化的示意图：
这个图很清晰的说明了利率的变化:
当使用率不超过最佳使用率时, 利率 = 基本利率 + 使用率 * slope1-rate 当使用率超过最佳使用率时, 利率 = 基本利率 + slope1-rate + (使用率-最佳使用率) * slope2-rate 从图中可知, 当使用率超过最佳使用率时，利率上涨的速度非常快, 这促使借款人尽快归还借款，否则，就很有可能被清算。
liquidityIndex 这是指标是 token/atoken 的存币利率
主要用到的地方:
存币 deposit 将用户的token转入合约，mint aToken并转给用户.
将 token mint 为 atoken，换算关系为:
atoken 数量 = token 数量 / liquidityIndex 取回 withdraw 将用户的 aToken 转入合约并销毁, 将对应的 token 转给用户
token 数量 = atoken 数量 * liquidityIndex 由于 liquidityIndex 在不断增长, 由上面两个公式就可以算出用户的存币利息所得。
variableBorrowIndex 借款利率 活期借款 当用户借款时, 系统会给用户 mint 借款的代币, 用来记录用户的借款, 已经随时间变化产生的利息.
varDebtToken 数量 = token 数量 / variableBorrowIndex 活期还款 当用户还款时，需要还的数量通过以下公式计算:
token 数量 = varDebtToken 数量 * variableBorrowIndex 清算 清算是风控的核心，在风控章节详细讨论。
定期借款 定期借款与活期借款类似，但有所不同。由于使用定期借款的比例非常少, 这里暂时跳过对定期借款的分析
利率的计算过程 利率的计算主要在文件 contracts\protocol\lendingpool\DefaultReserveInterestRateStrategy.sol 中，函数名为 calculateInterestRates.
计算的大概过程是:
总借款 = 活期借款 + 定期借款 资金利用率 = 总借款 / (总存款+总借款) 计算活期利率和定期利率。这两个利率都是两段式计算, 每一段的变化都是线性的。 a. 活期利率 = 基本活期利率 + 资金利用率 * slope1活期 (如果超过第一段, 还需要计算第二段的利率) b. 定期利率 = 基本定期利率 + 资金利用率 * slope1定期 加权平均借款利率 = (活期借款活期利率 + 定期借款平均定期利率) / 总借款， 这里的平均定期利率是函数入参，不再这里计算 currentLiquidityRate = (加权平均借款利率/总借款) * 资金利用率 * (1-储备率) 可以看到, currentLiquidityRate 的计算最复杂, 那么这个变量的用途是什么呢? 答案是用来计算存款利率(liquidityIndex)
对于利率的相关代码的分析，见: AAVE 利率代码解析
AAVE系列文章:
AAVE借贷协议简介 AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 清算; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 测试及部署;</content></entry><entry><title>AAVE源代码分析 -- AAVE代码整体架构</title><url>https://www.tiege.dev/post/aave/how-aave-interest-update/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag><tag>architecture</tag></tags><content type="html"> AAVE 整体架构 AAVE是一个借贷协议, 因此, 核心是围绕着存款，借款，还款，清算这四大环节展开的。我认为, AAVE 之所以看起来很复杂, 非常重要的一点是因为定期借款的存在, 极大的提高了利率模型的复杂度, 否则, AAVE 应该更加清晰。
AAVE 架构图如下:
目录结构及文件 合约主要在 contracts 目录下, contracts 目录结构如下：
├─adapters // 外部合约适配层 │ └─interfaces ├─dependencies // 一些基础库, 大部分基于 openzeppelin 修改 │ └─openzeppelin │ ├─contracts │ └─upgradeability ├─deployments // 部署相关 ├─flashloan // 闪电贷 │ ├─base │ └─interfaces ├─interfaces // 接口定义 ├─misc │ └─interfaces ├─mocks // 测试相关 │ ├─attacks │ ├─dependencies │ │ └─weth │ ├─flashloan │ ├─oracle │ │ └─CLAggregators │ ├─swap │ ├─tokens │ └─upgradeability └─protocol // 核心实现, 核心代码全部在这个目录下 ├─configuration ├─lendingpool ├─libraries │ ├─aave-upgradeability │ ├─configuration │ ├─helpers │ ├─logic │ ├─math │ └─types └─tokenization └─base 结合 AAVE 的部署代码, 算上Mock合约, AAVE 大概有 30 个合约:
LendingPoolAddressesProvider = 'LendingPoolAddressesProvider', LendingPoolAddressesProviderRegistry = 'LendingPoolAddressesProviderRegistry', LendingPoolParametersProvider = 'LendingPoolParametersProvider', LendingPoolConfigurator = 'LendingPoolConfigurator', ValidationLogic = 'ValidationLogic', ReserveLogic = 'ReserveLogic', GenericLogic = 'GenericLogic', LendingPool = 'LendingPool', PriceOracle = 'PriceOracle', Proxy = 'Proxy', LendingRateOracle = 'LendingRateOracle', AaveOracle = 'AaveOracle', DefaultReserveInterestRateStrategy = 'DefaultReserveInterestRateStrategy', LendingPoolCollateralManager = 'LendingPoolCollateralManager', InitializableAdminUpgradeabilityProxy = 'InitializableAdminUpgradeabilityProxy', WalletBalanceProvider = 'WalletBalanceProvider', AToken = 'AToken', DelegationAwareAToken = 'DelegationAwareAToken', AaveProtocolDataProvider = 'AaveProtocolDataProvider', StableDebtToken = 'StableDebtToken', VariableDebtToken = 'VariableDebtToken', FeeProvider = 'FeeProvider', TokenDistributor = 'TokenDistributor', StableAndVariableTokensHelper = 'StableAndVariableTokensHelper', ATokensAndRatesHelper = 'ATokensAndRatesHelper', UiPoolDataProvider = 'UiPoolDataProvider', WETHGateway = 'WETHGateway', UniswapLiquiditySwapAdapter = 'UniswapLiquiditySwapAdapter', UniswapRepayAdapter = 'UniswapRepayAdapter', FlashLiquidationAdapter = 'FlashLiquidationAdapter', 以下是 Mock 合约 MockAToken = 'MockAToken', MockAggregator = 'MockAggregator', WETHMocked = 'WETHMocked', SelfdestructTransferMock = 'SelfdestructTransferMock', MockStableDebtToken = 'MockStableDebtToken', MockVariableDebtToken = 'MockVariableDebtToken', MockFlashLoanReceiver = 'MockFlashLoanReceiver', MockUniswapV2Router02 = 'MockUniswapV2Router02', MintableERC20 = 'MintableERC20', // mock MintableDelegationERC20 = 'MintableDelegationERC20', // mock 借贷核心 借贷核心包括:
利率的计算 AAVE 将利率的计算移到了三个library中，路径为 contracts\protocol\libraries\logic\, 主要是: GenericLogic.sol 计算用户 account
ReserveLogic.sol 核心中的核心, 各种利率的计算
ValidationLogic.sol 这个库主要是各种安全校验, 存款校验, 借款校验, 还款校验, 清算校验, 转账校验, 活期定期转换校验等等
LendPool LendPool 是借贷动作的入口, 包括存款，借款，还款，清算等动作。
LendingPoolCollateralManager 主要负责完成清算
DefaultReserveInterestRateStrategy 利率变化的策略：calculateInterestRates
tokenization AAVE 中用户的存款，借款都是以 token 的方式记录。Compound 中，只有存款是以 token 的方式记录，借款并没有 tokenization. 其实, 我觉得借款并没有 tokenization 的必要。
AToken 存款凭证，类似于 Compound 中的 cToken。当用户存入 token 时，AAVE 给用户 mint 对应的 aToken
DelegationAwareAToken AToken 的代理
StableDebtToken 定期借款 token, 用于记录用户的定期借款
VariableDebtToken 活期借款 token, 用于记录用户的活期借款
市场及Provider、配置管理 LendingPoolAddressesProvider LendingPoolAddressesProviderRegistry LendingPoolParametersProvider LendingPoolConfigurator Oracle 辅助合约 AaveProtocolDataProvider 把一些整合并计算好, 方便前端调用
UiPoolDataProvider 把一些整合并计算好, 方便前端调用
StableAndVariableTokensHelper 辅助管理合约, 同时设置多个 asset 的 borrowRate
WalletBalanceProvider 查询 balance 信息, 并不是很必要, 实际上可以通过 multicall 来完成这样的功能。当然, 这样可以更有针对性的获取数据, 速度也更快
ATokensAndRatesHelper 辅助管理合约, 设置配置信息
adapter 主要是 uniswap adapter，包括以下几个合约:
UniswapLiquiditySwapAdapter UniswapRepayAdapter FlashLiquidationAdapter Proxy LendPool 的 proxy 这么多合约确实让人眼花缭乱，然而，我们可以先从核心开始分析，也就是利率模型和风险控制相关的合约，大约7-8个合约。</content></entry><entry><title>About</title><url>https://www.tiege.dev/about/</url><categories/><tags/><content type="html"> 铁叔 老年程序员，以代码为生计，正在为世界的去中心化事业而奋斗。
Older programmers, who coding for a living, and fighting for a decentralize world.
projects technology Rust golang C/C++ smart contract &amp; solidity java/Spring frontend</content></entry><entry><title>solidity函数selector的计算</title><url>https://www.tiege.dev/post/evm-selector/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag></tags><content type="html"> solidity 中有函数选择器(selector)的概念.
什么是 selector 在 solidity 中，所有 public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。
evm 函数选择器是一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节(高位在左的大端序) (译注：这里的 高位在左的大端序，指最高位字节存储在最低位地址上的一种串行化编码方式，即高位字节在左)。 这种签名被定义为基础原型的规范表达，基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。
简单来说，就是函数原型的 sha-3 hash值。
selector 有什么用途 在 以太坊Ethereum 生态系统中， 应用二进制接口 Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。
我们假定合约函数的接口都是强类型的，且在编译时是可知的和静态的；不提供自我检查机制。我们假定在编译时，所有合约要调用的其他合约接口定义都是可用的。
这份手册并不针对那些动态合约接口或者仅在运行时才可获知的合约接口。如果这种场景变得很重要，你可以使用 以太坊Ethereum 生态系统中其他更合适的基础设施来处理它们。
官方说明： https://docs.soliditylang.org/en/v0.8.7/abi-spec.html
如何计算 selector selector 可以通过两种方式获取，一种是查询 function.selector，另一种就是自己计算。
写个简单的测试合约，就能秒懂。
// SPDX-License-Identifier: MIT pragma solidity >=0.6.0; pragma experimental ABIEncoderV2; interface IABI { function initialize(address a, address b, address c, address d) external; } contract ABI { function initiliaze(address a, address b, address c, address d) public { } function getCodeByKeccak() public pure returns (bytes4) { return bytes4(keccak256(bytes("initialize(address,address,address,address)"))); } function getCodeBySelector() public view returns (bytes4) { IABI addr = IABI(address(this)); return addr.initialize.selector; } } 当计算函数选择器(selector)时，计算传入bytes数组有两点需要注意：
函数参数只有类型，没有名称，例如上例中的 initialize(address,address,address,address) 参数中间没有空格！参数中间没有空格！参数中间没有空格！ 如果要在链下计算，可以通过 ethers 提供的工具函数 id，代码如下：
import { id } from 'ethers/lib/utils'; const hash = id('initialize(address,address,address,address)') , selector = hash.slice(0, 10) selector 重复怎么办？ 如果一个合约中有重复的 selector，编译器会报错。
如果函数原型的参数是自定义的结构体, 怎么办? 如果是结构体, 在计算 selector 时, 将结构体展开为 tuple 来计算。例如：
struct Reward { address ctoken; address underlying; uint256 amount; uint256 debt; uint256 pending; address benefit; address owner; address[] path; }, function calcReward(Reword r, address to) returns (uint256); 在计算函数 calcReward 的selector时, 实际上是计算
calcReward((address,address,uint256,uint256,uint256,address,address,address[]),address) 这个字符串的 id
对于比较复杂的情况，我建议使用 ethers 库的 Interface 来计算函数的 selector, 链接: https://docs.ethers.io/v5/api/utils/abi/interface/
根据ABI创建 Interface
使用 Interface.getSighash() 获取函数的 selector
使用 Interface.getFunction('xxx').format('sighash') 获取计算 selector 的函数签名
完整的示例如下:
const { expect } = require("chai"); const { ethers } = require("hardhat"); describe("ABI selector", function() { it('selector', async () => { const iface = new ethers.utils.Interface([ // Constructor "constructor(string symbol, string name)", // State mutating method "function transferFrom(address from, address to, uint amount)", // State mutating method, which is payable "function mint(uint amount) payable", // Constant method (i.e. "view" or "pure") "function balanceOf(address owner) view returns (uint)", // An Event "event Transfer(address indexed from, address indexed to, uint256 amount)", // A Custom Solidity Error "error AccountLocked(address owner, uint256 balance)", // Examples with structured types "function addUser(tuple(string name, address addr) user) returns (uint id)", "function addUsers(tuple(string name, address addr)[] user) returns (uint[] id)", "function getUser(uint id) view returns (tuple(string name, address addr) user)" ]); console.log('addUsers getSighash: %s', iface.getSighash('addUsers')) let addUserFormat = iface.getFunction('addUsers').format(ethers.utils.FormatTypes.getSighash) console.log('addUsers format: %s', addUserFormat) console.log('addUsers selector:', ethers.utils.id(addUserFormat).slice(0, 10)) }) })</content></entry><entry><title>AAVE源代码分析 -- AAVE借贷协议简介</title><url>https://www.tiege.dev/post/aave/brief-introduction-to-aave-protocol/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag></tags><content type="html"> DEFI 上最初的应用就是借贷应用。借贷，顾名思义，是一个允许用户借贷代币的智能合约，它与银行类似，存款人把钱存入到借贷应用中(更具体的说，就是某个智能合约)，借贷应用把你的钱借给借款人，并随着时间的推移赚取利息。当借款人资不抵债时，会触发清算，任何人都可以参与清算，清算成功时清算人将获取一定比例的清算奖励。同时，借贷应用的清算系统能够确保借贷系统的稳定，进而保证存款人的利益。
DEFI 借贷在以下几个方面与银行不同:
利息的计算; a. DEFI 借贷利息的计算是从你存入的块开始计算，到你取出的块停止计算； b. DEFI 借贷的利息浮动范围很广，跟资金利用率(可以简单理解为 贷出资金/总借贷金额)息息相关，大多数借贷系统都设置比例，当资金利用率超过该比例时，利息会上涨的非常快，且利息很高，因此，这对于借款人来说，是非常不利的; c. 所有借款都必须有超额抵押，不存在信用贷款的概念;
清算 a. DEFI 借贷的所有存入，借出都是公开透明的; b. DEFI 借贷的清算标准是固定的; c. 任何人都可以进行清算，并且，清算人可以获取丰厚的清算奖励，通常是清算金额10% d. 由于清算奖励的巨大诱惑，且公开透明的数据，可以保证清算工作的稳定运行；
闪电贷 闪电贷是 AAVE 的一个巨大创新，所谓闪电贷，不是银行的闪电贷，这里的闪电贷是指，在一个区块交易中，同时完成先贷后还的操作。举个例子，现在有一个套利机会，但是你有没有资金，这时候，你就可以使用闪电贷，借出资产，完成套利，归还资金和利息，剩下的就是你的套利收益。
闪电贷也被很多人用于合约攻击，获取更大的收益。最近发生的很多起攻击事件，都是使用闪电贷的资金作为来源。
存款标的。 你可以将很多标的存入银行，由银行来对你的标的进行资产评估；而 DEFI 借贷只能存入部分 token, 因为 token 有公开定价, 而资产评估必须要链下评估，难以在链上完成。 DEFI 的借贷经历了三个发展阶段, 第一阶段的代表作是 MakerDAO, 第二阶段的代表作是 Compound, 第三阶段的代表作是 AAVE.
毫无疑问, Makerdao 是开创者; Compound 重新设计了利率模型, 可以说此后所有的借贷模型都是在 Compound 的基础之上发展而来, 从而奠定了 Compound 的江湖地位; AAVE 则是集大成者, AAVE 的借贷模型与 Compound 相同, 与Compound, MakerDAO 相比, AAVE 有以下特点:
AAVE 最大的创新就是引入了 闪电贷 (flashloan) 这个大杀器, 从此以后, 只有在链上有机会套利或者攻击, 你根本不用担心资金问题; 闪电贷也是链上借贷的独特优势, 在传统的金融行业中, 根本不存在这样的功能; AAVE 还有固定利率功能。我们知道, Compound 的利率是在不断的变化的，跟资金使用率息息相关, 当资金使用率突然升高时，借款利率会急速上升，对于长期资金使用者来说，这是无法承受的，AAVE引入了固定利率，从而解决了有长期资金需求借款人的借贷问题； AAVE 的代码比 Compound 写的更好, 更加工整, 框架清晰, 可读性, 可维护性都比 Compound 高几个档次 AAVE 更加安全。AAVE 的代码质量更高，模块化、结构化更好，测试更加充分，安全性更高。前几天 Cream protocol 发生的被攻击事件，让 Cream 损失了几千万美元。如果 Cream 当初是 fork 了 AAVE 的代码，这个攻击就无法进行。原理后面再详细分析 与swap市场 uniswap 一家独大不同，目前，借贷市场还处于三国鼎立的阶段，MakerDao, Compound, AAVE 各有优势, AAVE 在存款数量上有一定优势, Compound用户数最多，群众基础较好; MakerDao 锁仓金额较多；当然，这三者各有所长，差距不是非常明显, 其他模仿者就和这三大巨头的差距比较大，在没有大的创新的情况下，很难挑战这三大巨头。
由于 AAVE 比 Compound 代码更复杂，因此，目前 bsc、heco 这些链上的借贷市场几乎都是 fork Compound 代码，同时，由于这些团队追求快速上线，也没有对 Compound 进行深入研究，导致最终上线的产品不敢改也不能改，最多的就是把 cToken 改成各种 xToken，反正圈钱发币为主，不影响使用。
从学习的角度看，AAVE 代码质量非常优秀，比 Compound 高出好几个档次, AAVE v1版本就已经非常规范，v2版本更是青出于蓝而胜于蓝，从各个方面来看，都堪称典范:
结构非常清晰，interface, library, 实现，核心代码，适配层分门别类，各司其职； 完整的测试代码； 完整的部署代码； 完善的官方文档，白皮书等； 完善的周边 sdk，代码示例； 统一的代码风格，统一的注释风格，所有函数都有注释； 完善的代码检查，lint； Library 的应用真是炉火纯青 WETHGateway 的引入，统一了 ETH 和 Token, 这一点我觉得比 uniswap 做的好，uniswap 的 Router 合约有很多专门为 ETH 服务的接口，如果改成这种方式，会更加清晰； 教科书级别 Proxy 应用, 当然, 目前 openzeppelin 的代理是更加通用的解决方案 唯一能与之相提并论的是 uniswap, 当然, uniswap 把前端界面也开源了， 而 AAVE 并没有开源前端界面, 这是 AAVE 不如 uniswap 的地方。
我们将推出有一系列的文章来讲解 AAVE 的代码: 0. AAVE借贷协议简介
AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 风险控制; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 部署;</content></entry><entry><title>libuv与TCP Keepalive</title><url>https://www.tiege.dev/post/libuv-and-tcp-keepalive/</url><categories><category>c/c++</category></categories><tags><tag>libuv</tag><tag>tcp</tag><tag>TCP Keepalive</tag><tag>linux</tag></tags><content type="html"> libuv 与 TCP Keepalive 关于 keepalive 这里的keepalive与HTTP的keepalive不同，这里的keepalive是TCP层的keepalive，用处是当两台机器之间通信时，中间网络出现故障，这时，两端并无法感知网络故障这个事件，无法及时发现网络故障。
HTTP的keepalive是指，一个请求在请求头部增加一个keep alive的行，这时，服务端传输完成后，不会关闭这个TCP连接，还可以继续下次HTTP请求，提高了效率。
Linux内核关于TCP keepalive的说明在这里： http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html
其中：
tcp_keepalive_time the interval between the last data packet sent (simple ACKs are not considered data) and the first keepalive probe; after the connection is marked to need keepalive, this counter is not used any further tcp_keepalive_intvl the interval between subsequential keepalive probes, regardless of what the connection has exchanged in the meantime tcp_keepalive_probes the number of unacknowledged probes to send before considering the connection dead and notifying the application layer 大致翻译一下就是
tcp_keepalive_time 当一台机器在 N 秒内，还没有收到对方的任何数据时，开始 keepalive 探测对方是否正常 tcp_keepalive_intvl keepalive报文发送的间隔，单位秒 tcp_keepalive_probes keepalive报文探测次数 也就是说，在 tcp_keepalive_time 秒内仍未收到对端数据时，开始发起 keepalive 探测，每隔 tcp_keepalive_intvl 发送一个探测报文，当 发送 tcp_keepalive_probes 探测报文，对方仍未响应时，关闭连接。
在Linux下，可以通过以下方式查看系统的keepalive配置：
[root@localhost ~]# cat /proc/sys/net/ipv4/ 1800 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_probes 9 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_intvl 75 keepalive 接口 设置一个套接字的keepalive的方法如下：
1. enable keepalive int on = 1; if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) { // log return -1; } 2. 设置 tcp_keepalive_time int idle = 10; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(int)) &lt; 0) { // log return -1; } 3. 设置 tcp_keepalive_probes int probes = 4; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;probes, sizeof(int)) &lt; 0) { // log return -1; } 4. 设置 tcp_keepalive_intvl int intvl = 1; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;intvl, sizeof(int)) &lt; 0) { // log return -1; } libuv 的 keepalive libuv提供的接口只能设置上面的两个：
enable keepalive 设置 tcp_keepalive_time libuv提供的接口为 uv_tcp_keepalive, 函数原型如下：
int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) Enable / disable TCP keep-alive. delay is the initial delay in seconds, ignored when enable is zero. 该函数的实现代码如下：
int uv__tcp_keepalive(int fd, int on, unsigned int delay) { if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) return -errno; #ifdef TCP_KEEPIDLE if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;delay, sizeof(delay))) return -errno; #endif /* Solaris/SmartOS, if you don't support keep-alive, * then don't advertise it in your system headers... */ /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ #if defined(TCP_KEEPALIVE) &amp;&amp; !defined(__sun) if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &amp;delay, sizeof(delay))) return -errno; #endif return 0; } int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) { int err; if (uv__stream_fd(handle) != -1) { err =uv__tcp_keepalive(uv__stream_fd(handle), on, delay); if (err) return err; } if (on) handle->flags |= UV_TCP_KEEPALIVE; else handle->flags &amp;= ~UV_TCP_KEEPALIVE; /* TODO Store delay if uv__stream_fd(handle) == -1 but don't want to enlarge * uv_tcp_t with an int that's almost never used... */ return 0; } 从上面的代码可以看出，当 uv__stream_fd(handle) 不成功时，仅仅设置该连接的flags位，实际上并没有用到delay这个参数。也就是说，只有当连接已经成功建立时，才能设置 tcp_keepalive_time，如果连接还没有建立成功，则这个值根本没有设置。
如果要设置后面两个数值的话，需要自己实现, 示例代码如下：
// // 设置 keepalive 相关的2个参数 // probes: 对应内核 tcp_keepalive_probes, 发送多少次keepalive报文还未收到回应时, close该连接 // intvl: 对应内核 tcp_keepalive_intvl, 发送keepalive报文的间隔时间 // idle: 对应内核 tcp_keepalive_time int set_keep_alive(const uv_handle_t* handle, int probes, int intvl, int idle) { int ret; uv_os_fd_t fd; ret = uv_fileno(handle, &amp;fd); if (ret &lt; 0) { return ret; } if (idle > 0) { if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(idle))) return -1; } // 设置 tcp_keepalive_intvl if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (const void *) &amp;intvl, sizeof(int)) &lt; 0 ) { return -1; } // 设置 tcp_keepalive_probes if ( setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (const void *) &amp;probes, sizeof(int)) &lt; 0) { return -1; } return 0; } 这个函数只能在连接建立成功后调用，因为只有连接建立成功才有fd，即uv_fileno才会返回成功。</content></entry></search>