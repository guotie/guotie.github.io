<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>openzeppelin 版本4.1.0-4.3.1中UUPS proxy 存在致命漏洞</title><url>https://www.tiege.dev/post/contract-proxy/uups-proxy-vulunerability/</url><categories><category>Defi</category><category>Solidity</category><category>安全</category></categories><tags><tag>Solidity</tag><tag>Proxy</tag><tag>vulunerability</tag><tag>openzeppelin</tag></tags><content type="html"> openzeppelin 的Proxy 有两种:
透明代理 Transparent proxy UUPS proxy 两者的最主要的区别是， upgradeTo 函数逻辑的位置。在透明代理中， upgradeTo 函数逻辑在proxy合约中；而在 UUPS 代理中， upgradeTo 函数逻辑在实现合约中。
漏洞 openzeppelin 的代理合约通常都由几个合约组成。每个可升级的部署都包括一个实现合约，实现合约中是可升级合约的逻辑；一个代理合约，保存合约的状态(也就是存储)。当代理合约升级时，将代理合约的实现地址指向行的实现地址即可。
代理合约升级示意图:
在版本4.1.0-4.3.1中，UUPSUpgradeable 合约的 upgradeTo 函数没有设置权限，任何人都可以调用该函数。因此，可以构造一个攻击合约，在攻击合约的 upgradeTo 中调用 SELFDESTRUCT, 然后调用实现合约的 upgradeTo, 参数为我们的攻击合约，这将导致实现合约销毁自己(这里很重要的一点是，调用 SELFDESTRUCT 不会导致失败！)，因此，代理合约的逻辑代码被销毁，导致整个合约宕机！
之前版本的 upgradeTo 函数的实现:
function upgradeTo(address newImplementation) external virtual { _authorizeUpgrade(newImplementation); _upgradeToAndCallSecure(newImplementation, bytes(""), false); } 4.3.2 版本 upgradeTo 函数的实现:
modifier onlyProxy() { require(address(this) != __self, "Function must be called through delegatecall"); require(_getImplementation() == __self, "Function must be called through active proxy"); _; } function upgradeTo(address newImplementation) external virtual onlyProxy { _authorizeUpgrade(newImplementation); _upgradeToAndCallSecure(newImplementation, new bytes(0), false); } 可以看到，现在实现合约的 upgradeTo 只有 proxy 合约可以调用。
UUPS 代理合约 upgradeTo 原理 UUPS合约的部署步骤如下：
首先，部署实现合约, 实现合约需继承合约 ERC1967UpgradeUpgradeable；
其次，部署 ERC1967Proxy 合约，在这个合约的初始化方法中，指定实现合约的地址为上一步部署的实现合约地址；
最后，调用 ERC1967Proxy 的 upgradeTo 函数。
upgradeTo 函数的代码：
function upgradeTo(address newImplementation) external virtual onlyProxy { _authorizeUpgrade(newImplementation); _upgradeToAndCallSecure(newImplementation, new bytes(0), false); } function _upgradeToAndCallSecure( address newImplementation, bytes memory data, bool forceCall ) internal { address oldImplementation = _getImplementation(); // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length > 0 || forceCall) { _functionDelegateCall(newImplementation, data); } // Perform rollback test if not already in progress StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT); if (!rollbackTesting.value) { // Trigger rollback using upgradeTo from the new implementation rollbackTesting.value = true; _functionDelegateCall( newImplementation, abi.encodeWithSignature("upgradeTo(address)", oldImplementation) ); rollbackTesting.value = false; // Check rollback was effective require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades"); // Finally reset to the new implementation and log the upgrade _upgradeTo(newImplementation); } } function _upgradeTo(address newImplementation) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); } function _setImplementation(address newImplementation) private { require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract"); StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation; } 其中， _authorizeUpgrade 是实现合约的权限验证，任何继承 ERC1967UpgradeUpgradeable 的合约都必须实现这个函数。这个函数通常是限制只有owner才能调用。
在 _upgradeToAndCallSecure 中，对新的实现合约执行了回滚测试 (rollbackTesting)，也就是，执行新的执行合约升级逻辑，使proxy升级到现在的实现合约，以确保新的实现合约的 upgradeTo 没有问题，确保新的实现合约可以继续升级。
当上述回滚测试没有问题时，将 _IMPLEMENTATION_SLOT 的地址设置为新的实现地址。
https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680</content></entry><entry><title>AAVE源代码分析 -- AAVE 部署及初始化</title><url>https://www.tiege.dev/post/aave/how-aave-deploy-and-initialize-contracts/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>deploy</tag><tag>Defi</tag><tag>initialize</tag></tags><content type="html"> 由于 AAVE 合约较多，因此 AAVE 的部署也比较复杂. AAVE 把部署分为7个任务，每个任务作为一个 hardhat task, 然后通过 full taks调用各个task，来完成整体的部署和初始化。
fulltask 在工程的 package.json 文件中，有几十个部署任务，其中，这个任务是部署主网并验证合约:
"aave:main:full:migration": "npm run compile &amp;&amp; npm run hardhat:main -- aave:mainnet --verify", 其中， aave:mainnet 是任务名称，这个任务的执行在 tasks\migrations\aave.mainnet.ts 文件中设定。文件主要内容如下:
// 1 部署 address provider 相关合约， POOL_NAME 为 Aave await DRE.run('full:deploy-address-provider', { pool: POOL_NAME, skipRegistry }); // 2 部署 lending pool 相关合约 await DRE.run('full:deploy-lending-pool', { pool: POOL_NAME }); // 3 部署 预言机 相关合约 await DRE.run('full:deploy-oracles', { pool: POOL_NAME }); // 4 部署 data-provider 相关合约 await DRE.run('full:data-provider', { pool: POOL_NAME }); // 5 部署 weth 网关 await DRE.run('full-deploy-weth-gateway', { pool: POOL_NAME }); // 6 初始化相关合约 await DRE.run('full:initialize-lending-pool', { pool: POOL_NAME }); if (verify) { printContracts(); // 7 验证合约 await DRE.run('verify:general', { all: true, pool: POOL_NAME }); // 8 验证 aToken 合约和 debt 合约 await DRE.run('verify:tokens', { pool: POOL_NAME }); } if (usingTenderly()) { } // 打印合约信息 printContracts(); 我们来看看每个task的任务.
1. full:deploy-address-provider 任务名称: full:deploy-address-provider
任务文件: tasks\full\1_address_provider.ts
任务说明： 部署 address registry 和 address provider
任务执行:
部署 LendingPoolAddressesProvider 合约, 参数 marketId (例如 Aave, AMM); 调用 add-market-to-registry 任务; 如果 registry 不存在, 调用 full:deploy-address-provider-registry 部署 LendingPoolAddressesProviderRegistry 合约 registerAddressesProvider setPoolAdmin setEmergencyAdmin 2. full:deploy-lending-pool 任务名称: full:deploy-lending-pool
任务文件: tasks\full\2_lending_pool.ts
任务说明： 部署 lending pool 及相关合约
任务执行:
如果 LendPool 合约未部署，部署相关 Library 和 LendPool 合约， 初始化 LendPool; 使用第一步创建的 address registry 为 LendPool 部署代理合约，并将实现的指向 LendPool 合约; 部署 LendingPoolConfigurator; 调用 addressesProvider.setLendingPoolConfiguratorImpl, 该函数为 LendingPoolConfigurator 部署Proxy， 并设置 address provider 中的 LendingPoolConfigurator 地址 部署 StableAndVariableTokensHelper 合约 部署 ATokensAndRatesHelper 合约 3. full:deploy-oracles 任务名称: full:deploy-oracles
任务文件: tasks\full\3_oracles.ts
任务说明: 部署预言机合约
任务执行:
如果 AaveOracle 合约不存在, 部署 AaveOracle 合约, 设置 setAssetSources; 如果 LendingRateOracle 合约不存在，部署 LendingRateOracle 合约，初始化 setInitialMarketRatesInRatesOracleByHelper 设置 addressesProvider 的 setPriceOracle 为 AaveOracle 合约地址 设置 addressesProvider 的 LendingRateOracle 为 LendingRateOracle 合约地址 4. full:data-provider 任务名称: full:data-provider
任务文件: tasks\full\4_data-provider.ts
任务说明: 部署 Data Provider 合约
任务执行:
部署 AaveProtocolDataProvider 合约 5. weth 网关合约 任务名称：full-deploy-weth-gateway
任务文件: tasks\full\5-deploy-wethGateWay.ts
任务说明: 部署 WETHGateway 合约
任务执行:
部署 WETHGateway 合约 6. 初始化合约 任务名称: full:initialize-lending-pool
任务文件: tasks\full\6-initialize.ts
任务说明： 部署合约，设置代理，初始化
任务执行:
initReservesByHelper，为市场上的每一个token，执行以下步骤: 部署 AToken 合约 部署 StableDebtToken 合约 部署 VariableDebtToken 合约 部署 DefaultReserveInterestRateStrategy 合约 调用 LendingPoolConfigurator 合约为 aToken 合约、debtToken 合约部署代理, 并初始化 aToken 合约，debtToken 合约， configureReservesByHelper， 如果 LendingPoolCollateralManager 不存在，部署 LendingPoolCollateralManager 合约 设置 addressesProvider 的 LendingPoolCollateralManager 地址 部署 WalletBalancerProvider 合约，这个合约是只读合约，提供一些数据 配置 WETHGateway 合约 7. 验证合约 验证合约基本就是调用 hardhat-etherscan 来验证合约。
Atoken/debtToken aToken, debtToken (VariableDebtToken, StableDebtToken) 都是通过代理来运行的, 代理方式有点类似于 openzeppelin 的透明代理模式.
LendingPoolConfigurator 合约是 aToken debtToken 的代理的创建者和管理者, 同时， 对 aToken debtToken 的初始化，升级;
同时, LendingPoolConfigurator 又是由 AddressProvider 合约创建代理合约代理, 并通过 AddressProvider 合约来管理升级的;</content></entry><entry><title>AAVE源代码分析 -- AAVE 闪电贷</title><url>https://www.tiege.dev/post/aave/aave-flashloan/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>flashloan</tag><tag>闪电贷</tag></tags><content type="html"> flashloan flashloan, 闪电贷, 是指在无需任何抵押, 一个交易内完成借款，还款的借贷行为。 核心是在一个交易内完成, 正因为在一个交易内完成, 所以才无需抵押, 也正是由于在一个交易内完成，闪电贷使用区块链交易事务的特性，可以检查还款的额度是否>借款+利息, 如果不够, 则交易回滚, 任何数据都被还原, 也就是说, 借给你的资金也同样回滚，因此，没有任何风险。
此外，闪电贷的利息收入非常可观。一个块，也就几秒钟、十几秒钟时间，收取万分之9的利率，而且，一般使用闪电贷的，都是极大的借款量，动辄几千万，上亿美金。
闪电贷是去中心化的一大创新, 不知道是不是 AAVE 首先提出的。 现在很多协议都提供了闪电贷功能，例如:
借贷平台，如 AAVE, Compound 也有外挂提供闪电贷的功能; AAVE 闪电贷的默认利率是万分之9; uniswap. uniswap 在 swap 时，同样提供闪电贷功能. swap 时, pair 合约先把买到的token发给你, 你可以用这个token去盈利，然后再把卖出的token转入pair中。uniswap不收取额外费用，只是兑换的手续费为千三; token. 现在一些token也提供闪电贷的功能, 原理类似。手续费看具体实现。 flashloan 的流程 流程如下：
验证参数数据(ValidationLogic.validateFlashloan); 计算需要支付的利息，并把 token 转给用户; 调用用户合约执行用户的代码; 增加利息, 并将连本带利数量的 token 从用户合约转入 (用户有抵押物的情况，也可以选择使用转入贷款) flashloan 的收益归谁 答案是归所有存款人所有。在借贷结束后，flashloan 更新了存款利率指数，也就意味着所有的存款人获得了利息收入。
_reserves[vars.currentAsset].updateState(); // 计入收益 _reserves[vars.currentAsset].cumulateToLiquidityIndex( IERC20(vars.currentATokenAddress).totalSupply(), vars.currentPremium ); // 更新年化利率 _reserves[vars.currentAsset].updateInterestRates( vars.currentAsset, vars.currentATokenAddress, vars.currentAmountPlusPremium, 0 ); // 将 token 转回来 IERC20(vars.currentAsset).safeTransferFrom( receiverAddress, vars.currentATokenAddress, vars.currentAmountPlusPremium ); 值得注意的是，与 uniswap 闪电贷不同的是， AAVE 的闪电贷时，用户合约执行完成后， token 的转移是在 AAVE 合约中发起，从用户合约转入，而不是让用户将 token 转入 AAVE 合约。</content></entry><entry><title>AAVE源代码分析 -- AAVE 利率代码分析</title><url>https://www.tiege.dev/post/aave/aave-interest-update-code/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>利率模型</tag></tags><content type="html"> AAVE 利率模型中，几个参数之间互相影响，关系错综复杂，其中，固定利率比较绕，尤其是计算平均固定利率的公式，尤其难懂。不过，在实际的借贷中，有很多token不支持固定利率借贷，而且，在支持固定利率借贷token中，使用固定利率的借贷比例也很小，几乎不到1%，因此，对于固定利率部分，对于初学者来说可以先跳过。
在 AAVE 的利率计算中, 有几个地方值得说明:
AAVE 的利率更新是基于时间戳来计算利息的增加, Compound 是根据块数来计算利息的增加；两者触发利率更新的方式相同，都是由存款，取款，借款，还款等几个动作触发，每个块只计算一次； 存款利率的增加是线性的，贷款利率的增加是复利，指数级； 贷款收益的 reserve factor% (默认10%) 纳入平台金库; aToken, debtToken 中的 balanceOf 方法，返回的 amount 都是存款/贷款对应的 token 数量; 如果你只需要知道结论，AAVE的几个核心流程可以简单的总结如下(代码在 LendingPool 合约中):
存款 Deposit
校验数据(ValidationLogic.validateDeposit) 更新状态: updateState 更新利率: updateInterestRates 将 token 从用户转入 LendingPool 合约 mint aToken给用户: aToken amount = token amount / liquidityIndex emit Deposit事件 取款 Withdraw
查询用户token资产数量，注意: 是token资产数量, 而不是 aToken 数量. 虽然这里调用的是 aToken.balanceOf(), 看上去好像是 aToken 的余额，但事件上，这个函数会计算当前块 aToken 对应的 token 的数量； 校验数据(ValidationLogic.validateWithdraw) 更新状态: updateState 更新利率: updateInterestRates 销毁用户的aToken，将对应的token转给用户 emit Withdraw 事件 借款 Borrow
通过价格预言机, 计算出借款对应的 ETH 价值 amountInETH (AAVE中所有的token都要换算为对应的ETH价值) 校验数据(ValidationLogic.validateBorrow) 更新状态: updateState 至关重要的一步：mint 对应的 debtToken, AAVE 的债务是通过 debtToken 来记录的，每个token 都会有对应的 stableDebtToken, variableDebtToken, 分别对应于定息借款和活息借款 更新利率: updateInterestRates 将用户借出的token转给用户 emit Borrow 事件 还款 Repay
查询定息借款和活息借款额度, 都是贷款 debtToken 对应的 token 的数量; 校验数据 (ValidationLogic.validateRepay) 更新状态: updateState 销毁 debtToken. 这里有一个很关键、很重要的细节，就是还款额度的计算: paybackAmount, 必须要非常仔细, 一旦出错, 就会造成重大损失 更新利率: updateInterestRates 将用户的 token 转入合约，完成还款 emit Repay 事件 最基本的操作就是以上这几个，其他的还有清算(专门讨论), 转换借款方式(定息转活息，活息转定息)
从上面的流程可以看出:
updateState 和 updateInterestRates 是两个非常关键的函数，所有的操作都要调用这两个方法； 对这两个方法的调用稍有不同，例如 存款，取款时，两个方法是一起调用的； 而借款中，在两个方法的调用之间，还有其他操作；为什么会这样呢? 所有利率的变化，都是由 updateState 和 updateInterestRates 计算并更新的，下面我们来看看这两个函数的实现细节。
updateState updateInterestRates 两个函数定义如下:
function updateState(DataTypes.ReserveData storage reserve) internal; function updateInterestRates( DataTypes.ReserveData storage reserve, address reserveAddress, address aTokenAddress, uint256 liquidityAdded, uint256 liquidityTaken ) internal; 这两个函数在 library ReserveLogic.sol 中, 传入的参数中都有 DataTypes.ReserveData storage reserve , ReserveData 我们前面介绍过，是储存利率相关字段的结构体; 这个参数的存储类型是 storage, 说明这两个函数可以直接修改合约中的状态。
updateState updateState 主要作用: 0. 获取最新的活息贷款数量, 即 variableDebtToken 的总数量;
更新存款利率指数(ReserveData.liquidityIndex)和活息贷款利率指数(ReserveData.variableBorrowIndex), 通过 _updateIndexes 方法 将产生的增量贷款利息的一部分(reserve factor) 存入小金库, 具体实现的方式是 mint Atoken 给 treasy 地址 updateInterestRates updateInterestRates 主要作用: 0. 更新 currentLiquidityRate;
更新 currentStableBorrowRate 更新 currentVariableBorrowRate 关键函数 _updateIndexes 一个细节是，虽然资金变化都每次都调用，但由于在一个块内，只有第一次调用时 liquidityIndex 和 variableBorrowIndex 发生变化，后续调用都不会变化，因为 timestamp 相同， calculateCompoundedInterest 和 calculateLinearInterest 都是返回 Ray(1e27).
不知道是否可以优化, 我提了一个issue: https://github.com/aave/protocol-v2/issues/237
function _updateIndexes( DataTypes.ReserveData storage reserve, uint256 scaledVariableDebt, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 timestamp // 上次更新的时间戳 ) internal returns (uint256, uint256) { // currentLiquidityRate 是在 updateInterestRates 中更新的 uint256 currentLiquidityRate = reserve.currentLiquidityRate; uint256 newLiquidityIndex = liquidityIndex; uint256 newVariableBorrowIndex = variableBorrowIndex; //only cumulating if there is any income being produced if (currentLiquidityRate > 0) { // 存款利率根据 currentLiquidityRate 线性累加 // 公式: cumulatedLiquidityInterest = currentLiquidityRate * (block.timestamp-timestamp)/SECONDS_PER_YEAR uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp); newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex); require(newLiquidityIndex &lt;= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW); // 更新存款利息指数 reserve.liquidityIndex = uint128(newLiquidityIndex); //as the liquidity rate might come only from stable rate loans, we need to ensure //that there is actual variable debt before accumulating if (scaledVariableDebt != 0) { // 计算这段时间累加的活息贷款利息, 复利方式计算 // 计算的实现是 泰勒级数展开 uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp); newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex); require( newVariableBorrowIndex &lt;= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW ); // 更新活息贷款利息指数 reserve.variableBorrowIndex = uint128(newVariableBorrowIndex); } } // 设置更新时间戳 //solium-disable-next-line reserve.lastUpdateTimestamp = uint40(block.timestamp); return (newLiquidityIndex, newVariableBorrowIndex); } updateInterestRates 更新年化利率
function updateInterestRates( DataTypes.ReserveData storage reserve, address reserveAddress, address aTokenAddress, uint256 liquidityAdded, uint256 liquidityTaken ) internal { UpdateInterestRatesLocalVars memory vars; vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress; // 定息借款 (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress) .getTotalSupplyAndAvgRate(); // 活息贷款, 折算为 token //calculates the total variable debt locally using the scaled total supply instead //of totalSupply(), as it's noticeably cheaper. Also, the index has been //updated by the previous updateState() call vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress) .scaledTotalSupply() .rayMul(reserve.variableBorrowIndex); // 根据利率策略，计算新的存款年化利率 活息贷款年化利率 定息贷款年化利率. calculateInterestRates 见下文分析 ( vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates( reserveAddress, aTokenAddress, liquidityAdded, liquidityTaken, vars.totalStableDebt, vars.totalVariableDebt, vars.avgStableRate, reserve.configuration.getReserveFactor() ); require(vars.newLiquidityRate &lt;= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW); require(vars.newStableRate &lt;= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW); require(vars.newVariableRate &lt;= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW); // 新的利率 reserve.currentLiquidityRate = uint128(vars.newLiquidityRate); reserve.currentStableBorrowRate = uint128(vars.newStableRate); reserve.currentVariableBorrowRate = uint128(vars.newVariableRate); emit ReserveDataUpdated( reserveAddress, vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate, reserve.liquidityIndex, reserve.variableBorrowIndex ); } calculateInterestRates 代码如下：
struct CalcInterestRatesLocalVars { uint256 totalDebt; uint256 currentVariableBorrowRate; uint256 currentStableBorrowRate; uint256 currentLiquidityRate; uint256 utilizationRate; } /** * @dev Calculates the interest rates depending on the reserve's state and configurations. * NOTE This function is kept for compatibility with the previous DefaultInterestRateStrategy interface. * New protocol implementation uses the new calculateInterestRates() interface * @param reserve The address of the reserve * @param availableLiquidity The liquidity available in the corresponding aToken * @param totalStableDebt The total borrowed from the reserve a stable rate * @param totalVariableDebt The total borrowed from the reserve at a variable rate * @param averageStableBorrowRate The weighted average of all the stable rate loans * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market * @return The liquidity rate, the stable borrow rate and the variable borrow rate **/ function calculateInterestRates( address reserve, uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 averageStableBorrowRate, uint256 reserveFactor ) public view override returns ( uint256, uint256, uint256 ) { CalcInterestRatesLocalVars memory vars; // 总借款 = 活息借款 + 定息借款 vars.totalDebt = totalStableDebt.add(totalVariableDebt); vars.currentVariableBorrowRate = 0; vars.currentStableBorrowRate = 0; vars.currentLiquidityRate = 0; // 资金利用率 = 总借款 / (总存款+总借款) // 忽略 rayDiv rayMul, 可以简单的认为是 div mul 即可 vars.utilizationRate = vars.totalDebt == 0 ? 0 : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt)); vars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle()) .getMarketBorrowRate(reserve); // 利率曲线: 两段式 // 资金利用率高于最佳利用率时，利率的计算 if (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) { uint256 excessUtilizationRateRatio = vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE); vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add( _stableRateSlope2.rayMul(excessUtilizationRateRatio) ); vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add( _variableRateSlope2.rayMul(excessUtilizationRateRatio) ); } else { vars.currentStableBorrowRate = vars.currentStableBorrowRate.add( _stableRateSlope1.rayMul(vars.utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE)) ); vars.currentVariableBorrowRate = _baseVariableBorrowRate.add( vars.utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE) ); } // currentLiquidityRate的计算 = (加权平均借款利率/总借款) * 资金利用率 * (1-储备率) // 加权平均借款利率 = (活息借款*活息利率 + 定息借款*平均定息利率) / 总借款 vars.currentLiquidityRate = _getOverallBorrowRate( totalStableDebt, totalVariableDebt, vars .currentVariableBorrowRate, averageStableBorrowRate ) .rayMul(vars.utilizationRate) .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor)); return ( vars.currentLiquidityRate, vars.currentStableBorrowRate, vars.currentVariableBorrowRate ); } /** * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt * @param totalStableDebt The total borrowed from the reserve a stable rate * @param totalVariableDebt The total borrowed from the reserve at a variable rate * @param currentVariableBorrowRate The current variable borrow rate of the reserve * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans * @return The weighted averaged borrow rate 加权平均借款利率: (活息借款*活息利率 + 定息借款*平均定息利率) / 总借款 **/ function _getOverallBorrowRate( uint256 totalStableDebt, uint256 totalVariableDebt, uint256 currentVariableBorrowRate, uint256 currentAverageStableBorrowRate ) internal pure returns (uint256) { uint256 totalDebt = totalStableDebt.add(totalVariableDebt); if (totalDebt == 0) return 0; uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate); uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate); uint256 overallBorrowRate = weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay()); return overallBorrowRate; } } 为什么要先调用 updateState, 然后再调用 updateInterestRates 简单的说，是因为 liquidityIndex 和 variableBorrowIndex 是由 currentLiquidityRate 和 currentVariableBorrowRate 计算出来的，而先调用 updateState, 然后再调用 updateInterestRates，就是说，在时刻 t1, 当存款或贷款无论变化多少次，liquidityIndex 和 variableBorrowIndex只变化一次； 而 currentLiquidityRate， currentVariableBorrowRate 和 currentStableBorrowRate 会随着金额的变化而变化。
在一个块中，liquidityIndex 和 variableBorrowIndex只变化一次, 这里 AAVE 的代码不如 Compound, 如果是同一个块，多了很多无用的运算；
就是说，你存款后，下一个块才开始有利息；同理，贷款也是如此。
定息贷款的 averageStableBorrowRate averageStableBorrowRate 对于定息贷款很重要， 影响到 资金使用率，进而影响到 存款利率。
averageStableBorrowRate 在 StableDebtToken.sol 合约中定义，在 mint 和 burn 是改变该值。
mint:
// _calculateBalanceIncrease 返回值: 贷款本金，本息合计，利息 (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf); // 用户新的平均贷款利率 = 某种加权平均??? vars.newStableRate = _usersStableRate[onBehalfOf] .rayMul(currentBalance.wadToRay()) .add(vars.amountInRay.rayMul(rate)) // rate 是入参， 值为 reserve.currentStableBorrowRate .rayDiv(currentBalance.add(amount).wadToRay()); require(vars.newStableRate &lt;= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW); // 每个用户都有一个_usersStableRate， 保存用户贷款时的利率 _usersStableRate[onBehalfOf] = vars.newStableRate; //solium-disable-next-line _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp); // 该 token 总的定息贷款平均利率, 与上面的更新逻辑一致 // Calculates the updated average stable rate vars.currentAvgStableRate = _avgStableRate = vars .currentAvgStableRate .rayMul(vars.previousSupply.wadToRay()) .add(rate.rayMul(vars.amountInRay)) .rayDiv(vars.nextSupply.wadToRay()); burn:
if (previousSupply &lt;= amount) { // 当定息贷款被还完时，清零 // 由于可能存在计算误差, 这里不能使用 previousSupply - amount _avgStableRate = 0; _totalSupply = 0; } else { nextSupply = _totalSupply = previousSupply.sub(amount); uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay()); uint256 secondTerm = userStableRate.rayMul(amount.wadToRay()); // For the same reason described above, when the last user is repaying it might // happen that user rate * user balance > avg rate * total supply. In that case, // we simply set the avg rate to 0 if (secondTerm >= firstTerm) { newAvgStableRate = _avgStableRate = _totalSupply = 0; } else { newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay()); } } 由于定息贷款用户的利息和平台的利息是独立计算的，感觉这里两个数据会存在不一致。</content></entry><entry><title>下一代撮合引擎 -- 基于消息驱动的并行撮合引擎</title><url>https://www.tiege.dev/post/matching-engine/next-generation-matching-engine-parallel-matching-engine-base-on-message/</url><categories><category>Defi</category><category>Matching-engine</category></categories><tags><tag>Matching-engine</tag><tag>Matching</tag><tag>撮合</tag><tag>撮合引擎</tag><tag>并行撮合</tag><tag>kafka</tag><tag>消息队列</tag><tag>交易所</tag><tag>CLOB</tag></tags><content type="html"> 中心化交易所都是基于CLOB (中央统一订单薄)进行撮合交易, 撮合交易的交易原则是价格优先，时间优先。撮合引擎对于交易所来说，是基石，是重中之重。撮合引擎需要稳定，高效，可扩展，且能够容灾，同时，要保证在极端行情下和故障的情况下，可以迅速恢复或者回滚。
基于消息驱动的并行撮合 这里提出一种基于消息驱动的并行撮合引擎，首先，基于消息驱动是指，撮合引擎的输入有且只有消息队列(例如kafka)；其次，什么是 并行撮合 ?
并行撮合是指，多台机器对订单同时撮合，不是1主N从的方式，也不是 Round-Robin，而是 同时撮合. 那么，一个很明显的问题，这样不会出现数据混乱吗？答案是在持久层(包括redis，数据库)，我们需要做可重入处理。也就是说，同一个订单(同一个消息id标识)，即使被撮合引擎撮合无数次，在持久层的状态也只会变化一次。
实现并行撮合，最为重要的有两点：一是状态机；一是可重入。
状态机 并行撮合的原理是，如果我们把撮合引擎看做一个状态机，输入是 kafka 消息，输出是下一个状态。该状态机依赖于上一个状态和输入消息，用数学表达如下:
f(0) = 初始状态 f(t) = f(m(t), f(t-1)) 其中: f(t) 是消息 t 对应的状态; m(t) 是消息 t 对于撮合引擎而言，当系统载入初始数据后，撮合过程不再依赖环境变量，也不依赖任何随机数据，对于数据的处理，结果是完全确定的。因此，从理论上说，撮合系统，在相同的初始条件，相同的输入，必然产生相同的输出，这就是并行撮合的原理。也就是说，我们不需要像传统的做法那样，在多台撮合引擎之间通过多播协议来同步数据，而是靠相同的初始条件，相同的输入数据，相同的处理流程，以及定时检查，来保证在 同一消息点 上，各个撮合引擎之间的数据的一致性。
Ok，撮合引擎之间的数据一致性可以保证了，这只是整个系统容灾的一小部分，对于整个系统来说，每个环节都是需要确保正确，可容灾。
可重入 可重入的数学表达式:
f(x) = f(f(x)) 即，对同样的输入x, 无论执行多少次，最终的结果是一样的。
对于持久存储，例如redis和数据库，我们通过 kafka sequece id 来保证不可重入。
首先，对于一个订单生命周期的每一次变动，都是由kafka消息触发的。例如，订单的创建，由用户发送买入或卖出请求触发；订单的撮合，是由新订单的进入触发；订单的结束，是撮合的结果，自然也是新的订单触发； 其次，用户的资产变动，也可以认为是由消息触发。用户的资产变动，主要由以下几个方面:
充币 提币 OTC 各种交易 最后，从更大的层面来说，不单是订单，资产，我们可以将所有的输入，都抽象为消息，然后，整个系统的任何变动，都是由基于消息触发。通过在持久层实现可重入，那么我们的整个系统就可以通过
问题来了，如何实现，如何保证正确性，如何保证一致性，如何容灾？
sequence id 作为状态同步的尺度 先是架构图： 架构图对应的消息流程如下：
消息进入kafka队列; 各台撮合引擎分别从kafka中读取数据，并独立撮合； 撮合引擎将撮合结果写入redis HA, redis HA 通过消息id来保证数据的可重入; 撮合引擎 写入redis成功 后，将需要修改的数据发送给kafka； 由其他模块结束步骤3的消息，延迟写入数据库。 kafka 是我们的核心单元，kafka的每一条消息都有一个sequence id，这是一个64位自增的正整数。sequence id 是我们的衡量状态的尺度, 我们依赖 kafka 的 sequence id 来保证数据的一致性。具体来讲，对于订单数据，我们保存在三个地方，撮合引擎的内存中，redis中，数据库中。我们需要保证的是，三者对于同一个 sequence id, 这三个地方对应的订单状态是一致的。
如何保证撮合引擎的数据一致性 理论上，每台撮合引擎初始数据一致，处理相同的消息，并且是按照相同的顺序处理，因此，在同一个消息点上，所有撮合引擎的内存中的orderbook是应该完全一致的。
当然，这只是理论上的。为了实际保证撮合的一致性，并能够检查验证这一结果，我们可以在kafka中设计一种消息，当撮合引擎收到此类消息时，计算内存中所有orderbook的hash值，然后发送给kafka，撮合引擎接收其他撮合引擎的hash值，并与自己的对比，如果hash值相同，则证明数据一致；如果不同，则需要撮合引擎对各个价位取hash，并继续比较，直到找到不同之处，然后由开发工程师分析为何会出现不一致。
我们可以非常频繁的对比撮合结果，例如，每10秒钟执行一次，这样，一旦出现不一致，我们可以快速根据当时的数据来分析定位问题。
上述是检查的措施，如果发生不一致的情况，如何处理？例如，我们已经确定了问题所在，并打算以某台撮合的数据为基准。这时，我们可以通过定义同步消息，让正确的撮合引擎把完整的orderbook发送给kafka，其他撮合引擎使用这个 orderbook 来覆盖自己原有的 orderbook 即可，跟启动时同步数据一样的流程。
其他撮合引擎启动时如何同步数据 由于数据在三个地方都有，因此，撮合引擎数据的同步可以从三个地方获取:
其他撮合引擎的内存中 redis中 数据库中 从1中获取最好，因为这是最新的数据，而且在撮合引擎中，具有更好的一致性，而从redis和数据库中，如果是集群的话，需要考虑是否数据的存储方式。具体来讲，如果我们需要同步一个交易对的 orderbook，在redis中，如果 orderbook 保存在cluster的多台机器上，这时，我们去读取orderbook的状态时，就很难保证在多台redis上读取到的数据对应的 sequence id 相同。
从撮合引擎同步数据，可以按照这样的流程来实现：
向kafka发送请求同步消息; 撮合引擎响应消息，将orderbook的数据发给kafka； 待同步的撮合引擎读取orderbook数据，拿到orderbook和这个状态所对应的sequence id，初始化orderbook后，从kafka 的这个 sequence id开始读取数据，并处理。 如果这时，主撮合引擎失败了，如何处理？由于这时没有任何撮合引擎继续处理消息，因此，redis集群和数据库集群都是停留在最后一个kafka 消息id对应的状态上，当然，由于数据库的状态同步比redis慢，我们优先从redis中同步数据。因为状态不在发生变化，这时，所有redis集群对应的kafka消息id都是一致的，因此，只需要把redis cluster中的数据读出来，然后恢复出orderbook即可。
如何容灾 因为多台机器同时撮合, 因此，该方案本身天生就是容灾的! 只需要保证所有撮合系统的内存在同一消息点的数据一致性即可。
定期检查机制 通过 kafka 发送 检查指令 消息, 撮合引擎收到该消息后, 对本引擎的交易对的 orderbook 做 hash 运算, 然后将结果发出来对比，必须保证多台撮合引擎的 hash 值完全一致, 否则就需要定位排查为何 hash 值不一致。
优化 按照上面的方案，撮合引擎发送到kafka的消息会成倍的增长，由此带来后续的处理负荷也会成倍增加。如何优化这个架构？通过上面的分析，我们知道，
实现细节 我们后续会讨论一些实现的细节，例如撮合使用的数据结构，redis的存储格式，redis事务等。
方案优势 多台撮合引擎解耦 多台撮合引擎数据时刻一致 易于升级，易于测试 实时验证, 实时监测 缺点 消息量增加 1/N 倍 (架构1增加N倍，架构2增加1倍)
redis 写入次数增加 N 倍</content></entry><entry><title>AAVE源代码分析 -- AAVE Proxy 体系</title><url>https://www.tiege.dev/post/aave/how-aave-proxy/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>智能合约代理</tag></tags><content type="html"> 智能合约代理 智能合约为了能够升级的需求，重要的合约基本都是代理模式。AAVE 的代理非常复杂，要想深入理解 AAVE 的代理体系，就需要剥茧抽丝，一层一层的去仔细研究，才能理解其精髓。
AAVE 代理全局图：
按照 openzeppelin 对代理的定义, 智能合约的代理通常分为两种类型， 一种是透明代理(transparent)，一种是 uups 代理。两种代理的区别是:
目前， openzeppelin 更推荐使用 uups 方式的代理，更易用，也更简洁。
LendingPoolAddressesProvider 首先，要讲一下位于核心地位的 LendingPoolAddressesProvider 合约，这个合约是一个注册中心，也是一个管理中心。这个合约主要有两个作用:
创建、升级、管理其他合约； 作为注册中心，报错各个合约的地址，并未其他合约提供地址, 其他合约通过 LendingPoolAddressesProvider 来查询其他合约的地址; 以下几个核心合约都是通过这个合约创建、升级、初始化、管理的:
LENDING_POOL LENDING_POOL_CONFIGURATOR LendingPoolAddressesProvider，从名字可以看出，这个合约的一大功能就是提供 Address, 为谁提供 Address 呢？ 以下地址通过 LendingPoolAddressesProvider 来配置:
LENDING_POOL LENDING_POOL_CONFIGURATOR LENDING_POOL_COLLATERAL_MANAGER POOL_ADMIN EMERGENCY_ADMIN PRICE_ORACLE LENDING_RATE_ORACLE LendingPoolAddressesProvider 是如何创建、管理合约的呢？大概的步骤如下:
合约创建时，会先创建一个 Proxy 模板，然后把具体的实现设置到 Proxy 合约中； 上面几个合约中，都有一个 addressesProvider 变量，初始化第一步创建的合约时，将本合约的地址作为参数，初始化; 这几个合约需要相互调用，当调用时，首先通过 addressesProvider 来获取对方的地址，然后再调用。 创建其他合约的Proxy并设置代理的代码如下：
// 升级或创建合约 function _updateImpl(bytes32 id, address newAddress) internal { address payable proxyAddress = payable(_addresses[id]); InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(proxyAddress); bytes memory params = abi.encodeWithSignature('initialize(address)', address(this)); if (proxyAddress == address(0)) { // 代理合约不存在时，先创建代理合约模板，然后初始化代理合约 proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this)); proxy.initialize(newAddress, params); _addresses[id] = address(proxy); emit ProxyCreated(id, address(proxy)); } else { // 已经存在时, 升级合约 proxy.upgradeToAndCall(newAddress, params); } } LendingPoolConfigurator 与 LendingPoolAddressesProvider, LendingPoolConfigurator 用来创建以下合约的代理:
AToken StableDebtToken VariableDebtToken 代码如下:
function _initTokenWithProxy(address implementation, bytes memory initParams) internal returns (address) { // 部署 proxy 合约 InitializableImmutableAdminUpgradeabilityProxy proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this)); // 将proxy合约的实现指向 implementation, 并初始化 proxy 合约 proxy.initialize(implementation, initParams); return address(proxy); } 升级合约:
function _upgradeTokenImplementation( address proxyAddress, address implementation, bytes memory initParams ) internal { InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress)); proxy.upgradeToAndCall(implementation, initParams); } 关系图：</content></entry><entry><title>uniswap 环回交易的手续费</title><url>https://www.tiege.dev/post/uniswap/uniswap-loopback-swap-fee/</url><categories><category>Defi</category><category>uniswap</category></categories><tags><tag>uniswap</tag><tag>uniswap v2</tag><tag>Defi</tag><tag>Solidity</tag><tag>套利</tag><tag>arbitrage</tag></tags><content type="html"> uniswap 的交易费用，是通过 x * y = K 的恒等式中推导而来, 在特定的交易场景时，例如环回交易中，我们的交易成本可以做到远远低于额定手续费。
什么是环回交易 环回交易是在一个交易对 tokenA/tokenB 交易，先从 tokenA 兑换得到 tokenB, 然后立刻将得到的 tokenB 换回 tokenA 的交易。
uniswap v2 的标准费率是千分之三, 那么环回交易的成本就是千分之六, 这个成本相当之高. 如果我们仅仅是为了刷交易量, 我们需要一种有效的途径来降低手续费, 环回交易就是一种非常有效的途径。
理论推导 下面是我们的详细推导过程. 假设如下:
dx: 输入的 tokenA 数量 r0: tokenA 的 reserve 数量 r1: tokenB 的 reserve 数量 dy: 第一次 tokenA -> tokenB swap 的数量 ex: 第二次 swap tokenB -> tokenA 的数量 根据uniswap的公式, 计算如下：
dy = dx*997*r1/(1000*r0 + dx*997) R1 = r1 - dy R0 = r0 + dx ex = dy*997*R0/(1000*R1 + dy*997) 代入dy，化简后，可得：
ex = 997*997*dx*(r0+dx) / (1000*1000*r0 + 997*997*dx) 同时除以dx：
ex/dx = 997*997*(r0+dx) / (1000*1000*r0 + 997*997*dx) 由于ex是最终环回交易结束时我们的 tokenA 数量, dx 是我们 tokenA 的输入数量, 1-ex/dx 就是我们的手续费比例。
从上面的公式可知，最终环回交易的ex只跟输入dx和tokenA的reserve有关，而且，输入数量dx与tokenA reserve比值越高，最终得到的ex/dx 越接近1，也就是付出的手续费越少。
代码演算 测试代码如下：
Filename: loopbackSwap.js
const BigNumber = require('ethers').BigNumber const e18 = BigNumber.from('1000000000000000000') const getAmountOut = (amountIn, r0, r1) => { const amountInWithFee = amountIn.mul(997) , numerator = amountInWithFee.mul(r1) , denominator = r0.mul(1000).add(amountInWithFee); return numerator.div(denominator) } const getAmountBack = (amtIn, r0, r1, printable = false) => { const out = getAmountOut(amtIn, r0, r1) r0 = r0.add(amtIn) r1 = r1.sub(out) const dx = getAmountOut(out, r1, r0) if (printable) { console.info('swap x->y: out=%s r0=%s r1=%s backx=%s', out.toString(), r0.toString(), r1.toString(), dx.toString()) } return { amtInter: out, amtOut: dx } } function loopbackSwap() { const reserveA = BigNumber.from(1000000).mul(e18) , reserveB = BigNumber.from(2000000).mul(e18) , ratio = (multor) => reserveA.mul(multor).div(1000) let amts = [ 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 3000, 5000, 10000 ] for (let amt of amts) { let amtIn = ratio(amt) let { amtOut } = getAmountBack(amtIn, reserveA, reserveB) console.info('dx/reserve=%s amtOut/amtIn=%s', amt/1000, amtOut.mul(10000).div(amtIn).toNumber()/10000) } } loopbackSwap() run the scripts:
npx hardhat run loopbackSwap.js dx/reserve=0.001 amtOut/amtIn=0.994 dx/reserve=0.002 amtOut/amtIn=0.994 dx/reserve=0.005 amtOut/amtIn=0.994 dx/reserve=0.01 amtOut/amtIn=0.994 dx/reserve=0.02 amtOut/amtIn=0.9941 dx/reserve=0.05 amtOut/amtIn=0.9942 dx/reserve=0.1 amtOut/amtIn=0.9945 dx/reserve=0.2 amtOut/amtIn=0.995 dx/reserve=0.5 amtOut/amtIn=0.9959 dx/reserve=1 amtOut/amtIn=0.9969 dx/reserve=2 amtOut/amtIn=0.9979 dx/reserve=3 amtOut/amtIn=0.9984 dx/reserve=5 amtOut/amtIn=0.9989 dx/reserve=10 amtOut/amtIn=0.9994 从结果可以看出，当 dx/reserve 超过1后，手续费率极速降低，当dx/reserve=10，手续费仅为万分之6
由此，可以使用闪电贷，在较低的利率下，将大量资金从借贷池中借出，然后进行环回交易，在一些交易即挖矿的交易所中，可以通过这种方式降低挖矿手续费，套利获利。
实战 我们可以编写一个合约来执行我们的环回交易。
需要注意的是，我们不能直接将 uniswap router 的 path 参数设置为 [tokenA, tokenB, tokenA] 来进行环回交易，而必须分成两次swap, 首先是 [tokenA, tokenB]， 然后是 [tokenB, tokenA].
示例代码如下：
/// @dev swapLoopback swap tokenA to tokenB, then swap tokenB to tokenA /// @param _router uniswap-like router /// @param reward the reward token /// @param amountIn amount in /// @param amountOutMin just set to 0 /// @param path [tokenA, tokenB] function swapLoopback( address _router, // router address reward, // reward token uint amountIn, uint amountOutMin, address[] memory path ) public onlyOwner { address tokenIn = path[0]; uint tokenInitial = IERC20(tokenIn).balanceOf(address(this)); _approve(IERC20(tokenIn), address(_router)); // solhint-disable-next-line uint256 ts = block.timestamp + 60; uint[] memory amounts = IUniswapRouter(_router).swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), ts); path[0] = path[1]; path[1] = tokenIn; // console.log("amounts:", amounts[1]); _approve(IERC20(path[0]), address(_router)); amounts = IUniswapRouter(_router).swapExactTokensForTokens(amounts[1], amountOutMin, path, address(this), ts); // other arbitrage code with reward.. reward; }</content></entry><entry><title>元交易及其实现</title><url>https://www.tiege.dev/post/meta-transaction-and-implement/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag><tag>EIP-712</tag><tag>meta-transaction</tag></tags><content type="html"> 什么是元交易 简单来说，元交易(meta transaction)就是由第三方代理用户发送的交易。
元交易的流程如下：
用户构建交易参数，对交易参数签名 第三方将交易签名发送至 Relay/Forwarder 合约 Relay/Forwarder 合约验证用户的签名是否相符 Relay/Forwarder 调用最终的合约 普通的交易如下图所示:
元交易的如下图所示:
注： 图中的 Relayer 就是本文的 Forwarder 合约
元交易可以用来做什么 元交易大体有两个用途:
我们知道，去中心化的体验门槛很高，普通用户要玩去中心化，起码需要： a. 下载交易所，充币，认证，购买以太坊 b. 安装metamask，记住助记词，生吃地址； c. 交易所提币； d. 了解去中心化dapp, 理解原理, 使用dapp 上述任何一个步骤都非常麻烦，一整套流程走下来，半天就过去了
因此，使用元交易，可以让用户没有以太，就可以体验 dapp
安全 假如你有冷钱包，里面有很多钱，你不想让冷钱包直接触网，这时，你可以使用这种方式，让 Relayer/Forwarder 合约作为你的代理发送交易。
如何实现元交易 我们构建这样的一个数据结构:
struct ForwardRequest { // 用户地址 address from; // 用户要调用的合约地址 address to; // 交易发送的以太数量 uint256 value; // 设置的gas费, 可以不需要 uint256 gas; // Forwarder合约中记录的用户的nonce, 防止重放攻击 uint256 nonce; // 用户调用的函数和参数 bytes data; } 用户签名 待签名数据的构建基于 EIP-712, 如下:
/// @notice Returns a hash of the given data, prepared using EIP712 typed data hashing rules. /// @param from origin sender /// @param to contract to call /// @param value send ETH value /// @param nonce from's nonce /// @param data encodewithselector contract call params /// @return digest hash digest function getDigest( address from, address to, uint256 value, uint256 nonce, bytes memory data ) public view returns (bytes32 digest) { digest = _hashTypedDataV4( keccak256(abi.encode(_TYPE_HASH, from, to, value, nonce, keccak256(data)))); } 函数 _hashTypedDataV4 是根据 EIP-712 实现的, 代码如下:
function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) { return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash); } function _domainSeparatorV4() internal view returns (bytes32) { return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash()); } function _buildDomainSeparator( bytes32 typeHash, bytes32 nameHash, bytes32 versionHash ) private view returns (bytes32) { return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this))); } 其中，_EIP712NameHash _EIP712VersionHash 是合约创建时设置的
然后, 使用用户的私钥对上面算出来的 digest 签名:
import { utils } from 'ethers' const userkey = new utils.SigningKey(privateKey) , sig = userkey.signDigest(digest) , sigs = utils.joinSignature(sig) 合约验证签名合法性 验证签名的合法性基于两点:
ecrecover 从digest，签名中解出的地址与用户地址一致
nonce ForwardRequest.req 结构体中的 nonce 与合约中记录的nonce一致
验签代码如下:
using ECDSAUpgradeable for bytes32; function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) { bytes32 digest = getDigest(req.from, req.to, req.value, req.nonce, req.data); address signer = digest.recover(signature); return _nonces[req.from] == req.nonce &amp;&amp; signer == req.from; } msg.sender 的问题 当 Forwarder 合约最终调用 to 合约时，to 合约中使用 msg.sender 时, msg.sender 值为 Forwarder 合约地址。如果需要在 to 合约中使用用户地址，则需要做一些修改。
首先，Forwarder 合约调用 to 合约时，已经将用户的地址附加在调用参数的后面。to 合约的被调用函数并不需要知道这个参数的存在，因为 to 合约的函数取哪些参数，如何获取这些参数是在合约编译时，已经确定了, to 合约只是按照偏移量去 sload 数据. 在最后增加一个参数不会影响原来参数的获取，也不会像c/c++那样破坏堆栈。
Forwarder合约的执行:
(bool success, bytes memory returndata) = req.to.call{value: req.value}( abi.encodePacked(req.data, req.from) ); 这样，Forwarder 合约就把用户的地址传给了 to 合约，剩下的就交给 to 合约了。
然后，to 合约要怎么得到用户地址呢?
我们先来看看 openzeppelin 的 Context 合约:
abstract contract Context { function _msgSender() internal view virtual returns (address) { return msg.sender; } function _msgData() internal view virtual returns (bytes calldata) { return msg.data; } } 这是一个非常基础的合约，很多合约就是基于 Context 合约. 最开始看到这两个函数时，我非常迷惑, _msgSender() 就是简单的返回 msg.sender, 有什么作用呢？实际上，绝大部分时候，我们都是直接使用 msg.sender, 很少调用 _msgSender()。
在处理元交易时， _msgSender() 的作用就体现出来了, 我们可以重写 _msgSender 函数，来得到 用户地址，当然，前提是 to 合约需要配置 Forwarder 合约的地址。
在 to 合约中， 重写 _msgSender 函数代码如下：
address private _trustedForwarder; function isTrustedForwarder(address forwarder) public view virtual returns (bool) { return forwarder == _trustedForwarder; } function _msgSender() internal view virtual override(ContextUpgradeable) returns (address sender) { if (isTrustedForwarder(msg.sender)) { // The assembly code is more direct than the Solidity version using `abi.decode`. assembly { sender := shr(96, calldataload(sub(calldatasize(), 20))) } } else { return msg.sender; } } function _msgData() internal view virtual override(ContextUpgradeable) returns (bytes calldata) { if (isTrustedForwarder(msg.sender)) { return msg.data[:msg.data.length - 20]; } else { return msg.data; } } 这样, 就完成了对 to 合约的修改。 openzeppelin 的代码都是使用 _msgSender 来获取 msg.sender, 如果 to 合约继承了 openzeppelin 合约，那么继承的函数就直接支持了元交易。
此外，还有一种解决方式，就是在 to 合约中提供一个函数来设置用户的地址，Forwarder 调用 to 合约前，调用该函数设置用户地址；to合约执行时，从临时变量中读取用户地址; 执行完成后, Forwarder 合约在把地址重置。
显然这种方案没有第一种方案优雅，而且需要一个storage变量来存储用户地址，也增加了 gas 费用。
安全问题 重放攻击 例如，一个转账交易，如果没有检查，再次用同样的参数调用，就有可能再次转账。
解决的方式有很多种，一种是在 合约中为用户记录nonce值，每次交易自增nonce；另一种是记录交易hash，不允许重复的交易hash
样例代码 https://github.com/guotie/meta-tx
包含了使用, 部署，测试，Proxy 代理的实现。</content></entry><entry><title>AAVE源代码分析 -- AAVE 利率</title><url>https://www.tiege.dev/post/aave/aave-interest-model/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag></tags><content type="html"> 利率模型和风险控制是借贷协议的核心, 在AAVE中，利率的更新可以分为三个部分:
存币利率 活息借款利率 定息借款利率 至于风险控制，在后面的章节中，我们单独讨论。
ReserveData 结构体 ReserveData 是 AAVE 利率变动的核心数据结构。ReserveData 在 contracts\protocol\libraries\types\DataTypes.sol 文件中定义，相关代码如下：
// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties. struct ReserveData { // stores the reserve configuration // 各种配置, 就是一个 uint256, 不同的配置项使用不同为, 简单的 bitmask 算法 ReserveConfigurationMap configuration; // the liquidity index. Expressed in ray // 存币利率指数: aToken 与 token 的换算关系 uint128 liquidityIndex; // variable borrow index. Expressed in ray // 活息借款利率指数 uint128 variableBorrowIndex; // the current supply rate. Expressed in ray // 活息借款利率与定息借款利率的加权平均 uint128 currentLiquidityRate; // the current variable borrow rate. Expressed in ray // 活息借款利率 uint128 currentVariableBorrowRate; // the current stable borrow rate. Expressed in ray // 定息借款利率 uint128 currentStableBorrowRate; uint40 lastUpdateTimestamp; // tokens addresses address aTokenAddress; address stableDebtTokenAddress; address variableDebtTokenAddress; // address of the interest rate strategy address interestRateStrategyAddress; // the id of the reserve. Represents the position in the list of the active reserves uint8 id; } ReserveData 是借贷关系最核心的结构体, 每个市场上可以借贷的币种，都有一个对应的 ReserveData , 用来记录该币对的各种利率。
与利率相关的变量:
liquidityIndex: 存币利率 variableBorrowIndex: 活息借款利率 currentLiquidityRate: 流动率, 用于更新 liquidityIndex currentStableBorrowRate: 定息借款率 currentVariableBorrowRate: 活息借款率, 用于更新 variableBorrowIndex 两段式利率 利率的核心是供求关系。每当资金发生变化时，AAVE 都会自动调整利率. 利率的调整是基于供求关系，在 AAVE 或 Compound 中，反映资金供求关系的变量是资金利用率。资金利用率的定义是：
Utilisation = 总借款 / (总存款+总借款) 总借款 = 活息借款 + 定息借款 利率随供求关系变化的示意图：
这个图很清晰的说明了利率的变化:
当使用率不超过最佳使用率时, 利率 = 基本利率 + 使用率 * slope1-rate 当使用率超过最佳使用率时, 利率 = 基本利率 + slope1-rate + (使用率-最佳使用率) * slope2-rate 从图中可知, 当使用率超过最佳使用率时，利率上涨的速度非常快, 这促使借款人尽快归还借款，否则，就很有可能被清算。
liquidityIndex 这是指标是 token/atoken 的存币利率
主要用到的地方:
存币 deposit 将用户的token转入合约，mint aToken并转给用户.
将 token mint 为 atoken，换算关系为:
atoken 数量 = token 数量 / liquidityIndex 取回 withdraw 将用户的 aToken 转入合约并销毁, 将对应的 token 转给用户
token 数量 = atoken 数量 * liquidityIndex 由于 liquidityIndex 在不断增长, 由上面两个公式就可以算出用户的存币利息所得。
variableBorrowIndex 借款利率 活息借款 当用户借款时, 系统会给用户 mint 借款的代币, 用来记录用户的借款, 已经随时间变化产生的利息.
varDebtToken 数量 = token 数量 / variableBorrowIndex 活息还款 当用户还款时，需要还的数量通过以下公式计算:
token 数量 = varDebtToken 数量 * variableBorrowIndex 清算 清算是风控的核心，在风控章节详细讨论。
定息借款 定息借款与活息借款类似，但有所不同。由于使用定息借款的比例非常少, 这里暂时跳过对定息借款的分析
利率的计算过程 利率的计算主要在文件 contracts\protocol\lendingpool\DefaultReserveInterestRateStrategy.sol 中，函数名为 calculateInterestRates.
计算的大概过程是:
总借款 = 活息借款 + 定息借款 资金利用率 = 总借款 / (总存款+总借款) 计算活息利率和定息利率。这两个利率都是两段式计算, 每一段的变化都是线性的。 a. 活息利率 = 基本活息利率 + 资金利用率 * slope1活息 (如果超过第一段, 还需要计算第二段的利率) b. 定息利率 = 基本定息利率 + 资金利用率 * slope1定息 加权平均借款利率 = (活息借款活息利率 + 定息借款平均定息利率) / 总借款， 这里的平均定息利率是函数入参，不再这里计算 currentLiquidityRate = (加权平均借款利率/总借款) * 资金利用率 * (1-储备率) 可以看到, currentLiquidityRate 的计算最复杂, 那么这个变量的用途是什么呢? 答案是用来计算存款利率(liquidityIndex)
对于利率的相关代码的分析，见: AAVE 利率代码解析
AAVE系列文章:
AAVE借贷协议简介 AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 清算; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 测试及部署;</content></entry><entry><title>AAVE源代码分析 -- AAVE代码整体架构</title><url>https://www.tiege.dev/post/aave/how-aave-interest-update/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag><tag>architecture</tag></tags><content type="html"> AAVE 整体架构 AAVE是一个借贷协议, 因此, 核心是围绕着存款，借款，还款，清算这四大环节展开的。我认为, AAVE 之所以看起来很复杂, 非常重要的一点是因为定息借款的存在, 极大的提高了利率模型的复杂度, 否则, AAVE 应该更加清晰。
AAVE 架构图如下:
目录结构及文件 合约主要在 contracts 目录下, contracts 目录结构如下：
├─adapters // 外部合约适配层 │ └─interfaces ├─dependencies // 一些基础库, 大部分基于 openzeppelin 修改 │ └─openzeppelin │ ├─contracts │ └─upgradeability ├─deployments // 部署相关 ├─flashloan // 闪电贷 │ ├─base │ └─interfaces ├─interfaces // 接口定义 ├─misc │ └─interfaces ├─mocks // 测试相关 │ ├─attacks │ ├─dependencies │ │ └─weth │ ├─flashloan │ ├─oracle │ │ └─CLAggregators │ ├─swap │ ├─tokens │ └─upgradeability └─protocol // 核心实现, 核心代码全部在这个目录下 ├─configuration ├─lendingpool ├─libraries │ ├─aave-upgradeability │ ├─configuration │ ├─helpers │ ├─logic │ ├─math │ └─types └─tokenization └─base 结合 AAVE 的部署代码, 算上Mock合约, AAVE 大概有 30 个合约:
LendingPoolAddressesProvider = 'LendingPoolAddressesProvider', LendingPoolAddressesProviderRegistry = 'LendingPoolAddressesProviderRegistry', LendingPoolParametersProvider = 'LendingPoolParametersProvider', LendingPoolConfigurator = 'LendingPoolConfigurator', ValidationLogic = 'ValidationLogic', ReserveLogic = 'ReserveLogic', GenericLogic = 'GenericLogic', LendingPool = 'LendingPool', PriceOracle = 'PriceOracle', Proxy = 'Proxy', LendingRateOracle = 'LendingRateOracle', AaveOracle = 'AaveOracle', DefaultReserveInterestRateStrategy = 'DefaultReserveInterestRateStrategy', LendingPoolCollateralManager = 'LendingPoolCollateralManager', InitializableAdminUpgradeabilityProxy = 'InitializableAdminUpgradeabilityProxy', WalletBalanceProvider = 'WalletBalanceProvider', AToken = 'AToken', DelegationAwareAToken = 'DelegationAwareAToken', AaveProtocolDataProvider = 'AaveProtocolDataProvider', StableDebtToken = 'StableDebtToken', VariableDebtToken = 'VariableDebtToken', FeeProvider = 'FeeProvider', TokenDistributor = 'TokenDistributor', StableAndVariableTokensHelper = 'StableAndVariableTokensHelper', ATokensAndRatesHelper = 'ATokensAndRatesHelper', UiPoolDataProvider = 'UiPoolDataProvider', WETHGateway = 'WETHGateway', UniswapLiquiditySwapAdapter = 'UniswapLiquiditySwapAdapter', UniswapRepayAdapter = 'UniswapRepayAdapter', FlashLiquidationAdapter = 'FlashLiquidationAdapter', 以下是 Mock 合约 MockAToken = 'MockAToken', MockAggregator = 'MockAggregator', WETHMocked = 'WETHMocked', SelfdestructTransferMock = 'SelfdestructTransferMock', MockStableDebtToken = 'MockStableDebtToken', MockVariableDebtToken = 'MockVariableDebtToken', MockFlashLoanReceiver = 'MockFlashLoanReceiver', MockUniswapV2Router02 = 'MockUniswapV2Router02', MintableERC20 = 'MintableERC20', // mock MintableDelegationERC20 = 'MintableDelegationERC20', // mock 借贷核心 借贷核心包括:
利率的计算 AAVE 将利率的计算移到了三个library中，路径为 contracts\protocol\libraries\logic\, 主要是: GenericLogic.sol 计算用户 account
ReserveLogic.sol 核心中的核心, 各种利率的计算
ValidationLogic.sol 这个库主要是各种安全校验, 存款校验, 借款校验, 还款校验, 清算校验, 转账校验, 活息定息转换校验等等
LendPool LendPool 是借贷动作的入口, 包括存款，借款，还款，清算等动作。
LendingPoolCollateralManager 主要负责完成清算
DefaultReserveInterestRateStrategy 利率变化的策略：calculateInterestRates
tokenization AAVE 中用户的存款，借款都是以 token 的方式记录。Compound 中，只有存款是以 token 的方式记录，借款并没有 tokenization. 其实, 我觉得借款并没有 tokenization 的必要。
AToken 存款凭证，类似于 Compound 中的 cToken。当用户存入 token 时，AAVE 给用户 mint 对应的 aToken
DelegationAwareAToken AToken 的代理
StableDebtToken 定息借款 token, 用于记录用户的定息借款
VariableDebtToken 活息借款 token, 用于记录用户的活息借款
市场及Provider、配置管理 LendingPoolAddressesProvider LendingPoolAddressesProviderRegistry LendingPoolParametersProvider LendingPoolConfigurator Oracle 辅助合约 AaveProtocolDataProvider 把一些整合并计算好, 方便前端调用
UiPoolDataProvider 把一些整合并计算好, 方便前端调用
StableAndVariableTokensHelper 辅助管理合约, 同时设置多个 asset 的 borrowRate
WalletBalanceProvider 查询 balance 信息, 并不是很必要, 实际上可以通过 multicall 来完成这样的功能。当然, 这样可以更有针对性的获取数据, 速度也更快
ATokensAndRatesHelper 辅助管理合约, 设置配置信息
adapter 主要是 uniswap adapter，包括以下几个合约:
UniswapLiquiditySwapAdapter UniswapRepayAdapter FlashLiquidationAdapter Proxy LendPool 的 proxy 这么多合约确实让人眼花缭乱，然而，我们可以先从核心开始分析，也就是利率模型和风险控制相关的合约，大约7-8个合约。</content></entry><entry><title>About</title><url>https://www.tiege.dev/about/</url><categories/><tags/><content type="html"> 铁叔 老年程序员，以代码为生计，正在为世界的去中心化事业而奋斗。
Older programmers, who coding for a living, and fighting for a decentralize world.
projects technology Rust golang C/C++ smart contract &amp; solidity java/Spring frontend</content></entry><entry><title>solidity函数selector的计算</title><url>https://www.tiege.dev/post/evm-selector/</url><categories><category>Defi</category><category>Solidity</category></categories><tags><tag>selector</tag><tag>Solidity</tag><tag>EVM</tag><tag>ABI</tag><tag>Ethereum</tag></tags><content type="html"> solidity 中有函数选择器(selector)的概念.
什么是 selector 在 solidity 中，所有 public (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。
evm 函数选择器是一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak 哈希的前 4 字节(高位在左的大端序) (译注：这里的 高位在左的大端序，指最高位字节存储在最低位地址上的一种串行化编码方式，即高位字节在左)。 这种签名被定义为基础原型的规范表达，基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。
简单来说，就是函数原型的 sha-3 hash值。
selector 有什么用途 在 以太坊Ethereum 生态系统中， 应用二进制接口 Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。
我们假定合约函数的接口都是强类型的，且在编译时是可知的和静态的；不提供自我检查机制。我们假定在编译时，所有合约要调用的其他合约接口定义都是可用的。
这份手册并不针对那些动态合约接口或者仅在运行时才可获知的合约接口。如果这种场景变得很重要，你可以使用 以太坊Ethereum 生态系统中其他更合适的基础设施来处理它们。
官方说明： https://docs.soliditylang.org/en/v0.8.7/abi-spec.html
如何计算 selector selector 可以通过两种方式获取，一种是查询 function.selector，另一种就是自己计算。
写个简单的测试合约，就能秒懂。
// SPDX-License-Identifier: MIT pragma solidity >=0.6.0; pragma experimental ABIEncoderV2; interface IABI { function initialize(address a, address b, address c, address d) external; } contract ABI { function initiliaze(address a, address b, address c, address d) public { } function getCodeByKeccak() public pure returns (bytes4) { return bytes4(keccak256(bytes("initialize(address,address,address,address)"))); } function getCodeBySelector() public view returns (bytes4) { IABI addr = IABI(address(this)); return addr.initialize.selector; } } 当计算函数选择器(selector)时，计算传入bytes数组有两点需要注意：
函数参数只有类型，没有名称，例如上例中的 initialize(address,address,address,address) 参数中间没有空格！参数中间没有空格！参数中间没有空格！ 如果要在链下计算，可以通过 ethers 提供的工具函数 id，代码如下：
import { id } from 'ethers/lib/utils'; const hash = id('initialize(address,address,address,address)') , selector = hash.slice(0, 10) selector 重复怎么办？ 如果一个合约中有重复的 selector，编译器会报错。
如果函数原型的参数是自定义的结构体, 怎么办? 如果是结构体, 在计算 selector 时, 将结构体展开为 tuple 来计算。例如：
struct Reward { address ctoken; address underlying; uint256 amount; uint256 debt; uint256 pending; address benefit; address owner; address[] path; }, function calcReward(Reword r, address to) returns (uint256); 在计算函数 calcReward 的selector时, 实际上是计算
calcReward((address,address,uint256,uint256,uint256,address,address,address[]),address) 这个字符串的 id
对于比较复杂的情况，我建议使用 ethers 库的 Interface 来计算函数的 selector, 链接: https://docs.ethers.io/v5/api/utils/abi/interface/
根据ABI创建 Interface
使用 Interface.getSighash() 获取函数的 selector
使用 Interface.getFunction('xxx').format('sighash') 获取计算 selector 的函数签名
完整的示例如下:
const { expect } = require("chai"); const { ethers } = require("hardhat"); describe("ABI selector", function() { it('selector', async () => { const iface = new ethers.utils.Interface([ // Constructor "constructor(string symbol, string name)", // State mutating method "function transferFrom(address from, address to, uint amount)", // State mutating method, which is payable "function mint(uint amount) payable", // Constant method (i.e. "view" or "pure") "function balanceOf(address owner) view returns (uint)", // An Event "event Transfer(address indexed from, address indexed to, uint256 amount)", // A Custom Solidity Error "error AccountLocked(address owner, uint256 balance)", // Examples with structured types "function addUser(tuple(string name, address addr) user) returns (uint id)", "function addUsers(tuple(string name, address addr)[] user) returns (uint[] id)", "function getUser(uint id) view returns (tuple(string name, address addr) user)" ]); console.log('addUsers getSighash: %s', iface.getSighash('addUsers')) let addUserFormat = iface.getFunction('addUsers').format(ethers.utils.FormatTypes.getSighash) console.log('addUsers format: %s', addUserFormat) console.log('addUsers selector:', ethers.utils.id(addUserFormat).slice(0, 10)) }) })</content></entry><entry><title>AAVE源代码分析 -- AAVE借贷协议简介</title><url>https://www.tiege.dev/post/aave/brief-introduction-to-aave-protocol/</url><categories><category>Defi</category><category>AAVE</category></categories><tags><tag>AAVE</tag><tag>Compound</tag><tag>Defi</tag><tag>Solidity</tag><tag>Dapp</tag><tag>Lend protocol</tag></tags><content type="html"> DEFI 上最初的应用就是借贷应用。借贷，顾名思义，是一个允许用户借贷代币的智能合约，它与银行类似，存款人把钱存入到借贷应用中(更具体的说，就是某个智能合约)，借贷应用把你的钱借给借款人，并随着时间的推移赚取利息。当借款人资不抵债时，会触发清算，任何人都可以参与清算，清算成功时清算人将获取一定比例的清算奖励。同时，借贷应用的清算系统能够确保借贷系统的稳定，进而保证存款人的利益。
DEFI 借贷在以下几个方面与银行不同:
利息的计算; a. DEFI 借贷利息的计算是从你存入的块开始计算，到你取出的块停止计算； b. DEFI 借贷的利息浮动范围很广，跟资金利用率(可以简单理解为 贷出资金/总借贷金额)息息相关，大多数借贷系统都设置比例，当资金利用率超过该比例时，利息会上涨的非常快，且利息很高，因此，这对于借款人来说，是非常不利的; c. 所有借款都必须有超额抵押，不存在信用贷款的概念;
清算 a. DEFI 借贷的所有存入，借出都是公开透明的; b. DEFI 借贷的清算标准是固定的; c. 任何人都可以进行清算，并且，清算人可以获取丰厚的清算奖励，通常是清算金额10% d. 由于清算奖励的巨大诱惑，且公开透明的数据，可以保证清算工作的稳定运行；
闪电贷 闪电贷是 AAVE 的一个巨大创新，所谓闪电贷，不是银行的闪电贷，这里的闪电贷是指，在一个区块交易中，同时完成先贷后还的操作。举个例子，现在有一个套利机会，但是你有没有资金，这时候，你就可以使用闪电贷，借出资产，完成套利，归还资金和利息，剩下的就是你的套利收益。
闪电贷也被很多人用于合约攻击，获取更大的收益。最近发生的很多起攻击事件，都是使用闪电贷的资金作为来源。
存款标的。 你可以将很多标的存入银行，由银行来对你的标的进行资产评估；而 DEFI 借贷只能存入部分 token, 因为 token 有公开定价, 而资产评估必须要链下评估，难以在链上完成。 DEFI 的借贷经历了三个发展阶段, 第一阶段的代表作是 MakerDAO, 第二阶段的代表作是 Compound, 第三阶段的代表作是 AAVE.
毫无疑问, Makerdao 是开创者; Compound 重新设计了利率模型, 可以说此后所有的借贷模型都是在 Compound 的基础之上发展而来, 从而奠定了 Compound 的江湖地位; AAVE 则是集大成者, AAVE 的借贷模型与 Compound 相同, 与Compound, MakerDAO 相比, AAVE 有以下特点:
AAVE 最大的创新就是引入了 闪电贷 (flashloan) 这个大杀器, 从此以后, 只有在链上有机会套利或者攻击, 你根本不用担心资金问题; 闪电贷也是链上借贷的独特优势, 在传统的金融行业中, 根本不存在这样的功能; AAVE 还有固定利率功能。我们知道, Compound 的利率是在不断的变化的，跟资金使用率息息相关, 当资金使用率突然升高时，借款利率会急速上升，对于长期资金使用者来说，这是无法承受的，AAVE引入了固定利率，从而解决了有长期资金需求借款人的借贷问题； AAVE 的代码比 Compound 写的更好, 更加工整, 框架清晰, 可读性, 可维护性都比 Compound 高几个档次 AAVE 更加安全。AAVE 的代码质量更高，模块化、结构化更好，测试更加充分，安全性更高。前几天 Cream protocol 发生的被攻击事件，让 Cream 损失了几千万美元。如果 Cream 当初是 fork 了 AAVE 的代码，这个攻击就无法进行。原理后面再详细分析 与swap市场 uniswap 一家独大不同，目前，借贷市场还处于三国鼎立的阶段，MakerDao, Compound, AAVE 各有优势, AAVE 在存款数量上有一定优势, Compound用户数最多，群众基础较好; MakerDao 锁仓金额较多；当然，这三者各有所长，差距不是非常明显, 其他模仿者就和这三大巨头的差距比较大，在没有大的创新的情况下，很难挑战这三大巨头。
由于 AAVE 比 Compound 代码更复杂，因此，目前 bsc、heco 这些链上的借贷市场几乎都是 fork Compound 代码，同时，由于这些团队追求快速上线，也没有对 Compound 进行深入研究，导致最终上线的产品不敢改也不能改，最多的就是把 cToken 改成各种 xToken，反正圈钱发币为主，不影响使用。
从学习的角度看，AAVE 代码质量非常优秀，比 Compound 高出好几个档次, AAVE v1版本就已经非常规范，v2版本更是青出于蓝而胜于蓝，从各个方面来看，都堪称典范:
结构非常清晰，interface, library, 实现，核心代码，适配层分门别类，各司其职； 完整的测试代码； 完整的部署代码； 完善的官方文档，白皮书等； 完善的周边 sdk，代码示例； 统一的代码风格，统一的注释风格，所有函数都有注释； 完善的代码检查，lint； Library 的应用真是炉火纯青 WETHGateway 的引入，统一了 ETH 和 Token, 这一点我觉得比 uniswap 做的好，uniswap 的 Router 合约有很多专门为 ETH 服务的接口，如果改成这种方式，会更加清晰； 教科书级别 Proxy 应用, 当然, 目前 openzeppelin 的代理是更加通用的解决方案 唯一能与之相提并论的是 uniswap, 当然, uniswap 把前端界面也开源了， 而 AAVE 并没有开源前端界面, 这是 AAVE 不如 uniswap 的地方。
我们将推出有一系列的文章来讲解 AAVE 的代码: 0. AAVE借贷协议简介
AAVE 代码整体结构介绍; AAVE 利率模型; AAVE 利率代码解析; AAVE 风险控制; AAVE 闪电贷; AAVE 各个模块之间如何解耦; AAVE Proxy 模式; AAVE 部署;</content></entry><entry><title>libuv与TCP Keepalive</title><url>https://www.tiege.dev/post/libuv-and-tcp-keepalive/</url><categories><category>c/c++</category></categories><tags><tag>libuv</tag><tag>tcp</tag><tag>TCP Keepalive</tag><tag>linux</tag></tags><content type="html"> libuv 与 TCP Keepalive 关于 keepalive 这里的keepalive与HTTP的keepalive不同，这里的keepalive是TCP层的keepalive，用处是当两台机器之间通信时，中间网络出现故障，这时，两端并无法感知网络故障这个事件，无法及时发现网络故障。
HTTP的keepalive是指，一个请求在请求头部增加一个keep alive的行，这时，服务端传输完成后，不会关闭这个TCP连接，还可以继续下次HTTP请求，提高了效率。
Linux内核关于TCP keepalive的说明在这里： http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html
其中：
tcp_keepalive_time the interval between the last data packet sent (simple ACKs are not considered data) and the first keepalive probe; after the connection is marked to need keepalive, this counter is not used any further tcp_keepalive_intvl the interval between subsequential keepalive probes, regardless of what the connection has exchanged in the meantime tcp_keepalive_probes the number of unacknowledged probes to send before considering the connection dead and notifying the application layer 大致翻译一下就是
tcp_keepalive_time 当一台机器在 N 秒内，还没有收到对方的任何数据时，开始 keepalive 探测对方是否正常 tcp_keepalive_intvl keepalive报文发送的间隔，单位秒 tcp_keepalive_probes keepalive报文探测次数 也就是说，在 tcp_keepalive_time 秒内仍未收到对端数据时，开始发起 keepalive 探测，每隔 tcp_keepalive_intvl 发送一个探测报文，当 发送 tcp_keepalive_probes 探测报文，对方仍未响应时，关闭连接。
在Linux下，可以通过以下方式查看系统的keepalive配置：
[root@localhost ~]# cat /proc/sys/net/ipv4/ 1800 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_probes 9 [root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_intvl 75 keepalive 接口 设置一个套接字的keepalive的方法如下：
1. enable keepalive int on = 1; if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) { // log return -1; } 2. 设置 tcp_keepalive_time int idle = 10; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(int)) &lt; 0) { // log return -1; } 3. 设置 tcp_keepalive_probes int probes = 4; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;probes, sizeof(int)) &lt; 0) { // log return -1; } 4. 设置 tcp_keepalive_intvl int intvl = 1; if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;intvl, sizeof(int)) &lt; 0) { // log return -1; } libuv 的 keepalive libuv提供的接口只能设置上面的两个：
enable keepalive 设置 tcp_keepalive_time libuv提供的接口为 uv_tcp_keepalive, 函数原型如下：
int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) Enable / disable TCP keep-alive. delay is the initial delay in seconds, ignored when enable is zero. 该函数的实现代码如下：
int uv__tcp_keepalive(int fd, int on, unsigned int delay) { if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) return -errno; #ifdef TCP_KEEPIDLE if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;delay, sizeof(delay))) return -errno; #endif /* Solaris/SmartOS, if you don't support keep-alive, * then don't advertise it in your system headers... */ /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ #if defined(TCP_KEEPALIVE) &amp;&amp; !defined(__sun) if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &amp;delay, sizeof(delay))) return -errno; #endif return 0; } int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) { int err; if (uv__stream_fd(handle) != -1) { err =uv__tcp_keepalive(uv__stream_fd(handle), on, delay); if (err) return err; } if (on) handle->flags |= UV_TCP_KEEPALIVE; else handle->flags &amp;= ~UV_TCP_KEEPALIVE; /* TODO Store delay if uv__stream_fd(handle) == -1 but don't want to enlarge * uv_tcp_t with an int that's almost never used... */ return 0; } 从上面的代码可以看出，当 uv__stream_fd(handle) 不成功时，仅仅设置该连接的flags位，实际上并没有用到delay这个参数。也就是说，只有当连接已经成功建立时，才能设置 tcp_keepalive_time，如果连接还没有建立成功，则这个值根本没有设置。
如果要设置后面两个数值的话，需要自己实现, 示例代码如下：
// // 设置 keepalive 相关的2个参数 // probes: 对应内核 tcp_keepalive_probes, 发送多少次keepalive报文还未收到回应时, close该连接 // intvl: 对应内核 tcp_keepalive_intvl, 发送keepalive报文的间隔时间 // idle: 对应内核 tcp_keepalive_time int set_keep_alive(const uv_handle_t* handle, int probes, int intvl, int idle) { int ret; uv_os_fd_t fd; ret = uv_fileno(handle, &amp;fd); if (ret &lt; 0) { return ret; } if (idle > 0) { if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(idle))) return -1; } // 设置 tcp_keepalive_intvl if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (const void *) &amp;intvl, sizeof(int)) &lt; 0 ) { return -1; } // 设置 tcp_keepalive_probes if ( setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (const void *) &amp;probes, sizeof(int)) &lt; 0) { return -1; } return 0; } 这个函数只能在连接建立成功后调用，因为只有连接建立成功才有fd，即uv_fileno才会返回成功。</content></entry><entry><title/><url>https://www.tiege.dev/post/futures-perps/a-great-sheet-of-perp-protocols/</url><categories/><tags/><content type="html"/></entry><entry><title/><url>https://www.tiege.dev/post/matching-engine/02-matching-engine-details/</url><categories/><tags/><content type="html"> redis 高可用 redis 事务 orderbook 在 redis 中的存储 数据库结构及订单存储 撮合引起启动时初始数据，及同步验证 启动
异步 哪些可以异步，哪些必须顺序执行?
故障定位，故障解决 性能</content></entry></search>