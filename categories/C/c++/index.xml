<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c/c++ on 铁叔</title><link>http://tiege.dev/categories/c/c++/</link><description>Recent content in c/c++ on 铁叔</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="http://tiege.dev/categories/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>libuv与TCP Keepalive</title><link>http://tiege.dev/post/libuv-and-tcp-keepalive/</link><pubDate>Sun, 02 Jul 2017 15:36:21 +0800</pubDate><guid>http://tiege.dev/post/libuv-and-tcp-keepalive/</guid><description>&lt;h1 id="libuv-与-tcp-keepalive">libuv 与 TCP Keepalive&lt;/h1>
&lt;h2 id="关于-keepalive">关于 keepalive&lt;/h2>
&lt;p>这里的keepalive与HTTP的keepalive不同，这里的keepalive是TCP层的keepalive，用处是当两台机器之间通信时，中间网络出现故障，这时，两端并无法感知网络故障这个事件，无法及时发现网络故障。&lt;/p>
&lt;p>HTTP的keepalive是指，一个请求在请求头部增加一个keep alive的行，这时，服务端传输完成后，不会关闭这个TCP连接，还可以继续下次HTTP请求，提高了效率。&lt;/p>
&lt;p>Linux内核关于TCP keepalive的说明在这里： &lt;a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html">http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html&lt;/a>&lt;/p></description></item></channel></rss>