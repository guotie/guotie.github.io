<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>  &middot; 铁哥 </title>


<link rel="stylesheet" href="http://guotie.github.io/css/slim.css">
<link rel="stylesheet" href="http://guotie.github.io/css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://guotie.github.io/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="http://guotie.github.io/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="铁哥" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="http://guotie.github.io/">铁哥</a></h1>
  <p class="site-tagline"></p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>
  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="post">
        <h2 class="post-title"><a href="http://guotie.github.io/posts/libuv%E4%B8%8Etcp-keepalive/"></a></h2>
        <div class="post-content">
          

<h1 id="libuv-与-tcp-keepalive">libuv 与 TCP keepalive</h1>

<h2 id="关于-keepalive">关于 keepalive</h2>

<p>这里的keepalive与HTTP的keepalive不同，这里的keepalive是TCP层的keepalive，用处是当两台机器之间通信是，中间网络出现故障，这时，两端并无法感知网络故障这个事件，无法及时发现网络故障。</p>

<p>HTTP的keepalive是指，一个请求在请求头部增加一个keep alive的行，这时，服务端传输完成后，不会关闭这个TCP连接，还可以继续下次HTTP请求，提高了效率。</p>

<p>Linux内核关于keepalive的说明在这里： <a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html">http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html</a></p>

<p>其中：</p>

<pre><code>tcp_keepalive_time

 the interval between the last data packet sent (simple ACKs are not considered data) and the first keepalive probe; after the connection is marked to need keepalive, this counter is not used any further

tcp_keepalive_intvl

 the interval between subsequential keepalive probes, regardless of what the connection has exchanged in the meantime

tcp_keepalive_probes

 the number of unacknowledged probes to send before considering the connection dead and notifying the application layer
</code></pre>

<p>大致翻译一下就是</p>

<pre><code>tcp_keepalive_time

当一台机器在 N 秒内，还没有收到对方的任何数据时，开始 keepalive 探测对方是否正常

tcp_keepalive_intvl

keepalive报文发送的间隔，单位秒

tcp_keepalive_probes

keepalive报文探测次数
</code></pre>

<p>也就是说，在 tcp_keepalive_time 秒内仍未收到对端数据时，开始发起 keepalive 探测，每隔 tcp_keepalive_intvl 发送一个探测报文，当 发送 tcp_keepalive_probes 探测报文，对方仍未响应时，关闭连接。</p>

<p>在Linux下，可以通过以下方式查看系统的keepalive配置：</p>

<pre><code>[root@localhost ~]# cat /proc/sys/net/ipv4/ 
1800
[root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_probes 
9
[root@localhost ~]# cat /proc/sys/net/ipv4/tcp_keepalive_intvl  
75
</code></pre>

<h2 id="keepalive-接口">keepalive 接口</h2>

<p>设置一个套接字的keepalive的方法如下：</p>

<h3 id="enable-keepalive">enable keepalive</h3>

<pre><code>int on = 1;
if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on))) {
	// log
    return -1;
}
</code></pre>

<h3 id="设置-tcp-keepalive-time">设置 tcp_keepalive_time</h3>

<pre><code>int idle = 10;
if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(int)) &lt; 0) {
  // log
  return -1;
}
</code></pre>

<h3 id="设置-tcp-keepalive-probes">设置 tcp_keepalive_probes</h3>

<pre><code>int probes = 4;
if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;probes, sizeof(int)) &lt; 0) {
  // log
  return -1;
}
</code></pre>

<h3 id="设置-tcp-keepalive-intvl">设置 tcp_keepalive_intvl</h3>

<pre><code>int intvl = 1;
if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;intvl, sizeof(int)) &lt; 0) {
  // log
  return -1;
}
</code></pre>

<h2 id="libuv-的-keepalive">libuv 的 keepalive</h2>

<p>libuv提供的接口只能设置上面的两个：</p>

<ol>
<li>enable keepalive</li>
<li>设置 tcp_keepalive_time</li>
</ol>

<p>libuv提供的接口为 uv_tcp_keepalive, 函数原型如下：</p>

<pre><code>int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay)
   Enable / disable TCP keep-alive. delay is the initial delay in seconds, ignored when enable is zero.
</code></pre>

<p>该函数的实现代码如下：</p>

<pre><code>
int uv__tcp_keepalive(int fd, int on, unsigned int delay) {
  if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on)))
    return -errno;

#ifdef TCP_KEEPIDLE
  if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;delay, sizeof(delay)))
    return -errno;
#endif

  /* Solaris/SmartOS, if you don't support keep-alive,
   * then don't advertise it in your system headers...
   */
  /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */
#if defined(TCP_KEEPALIVE) &amp;&amp; !defined(__sun)
  if (on &amp;&amp; setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &amp;delay, sizeof(delay)))
    return -errno;
#endif

  return 0;
}

int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) {
  int err;

  if (uv__stream_fd(handle) != -1) {
    err =uv__tcp_keepalive(uv__stream_fd(handle), on, delay);
    if (err)
      return err;
  }

  if (on)
    handle-&gt;flags |= UV_TCP_KEEPALIVE;
  else
    handle-&gt;flags &amp;= ~UV_TCP_KEEPALIVE;

  /* TODO Store delay if uv__stream_fd(handle) == -1 but don't want to enlarge
   *      uv_tcp_t with an int that's almost never used...
   */

  return 0;
}
</code></pre>

<p>从上面的代码可以看出，当 uv__stream_fd(handle) 不成功时，仅仅设置该连接的flags位，实际上并没有用到delay这个参数。也就是说，只有当连接已经成功建立时，才能设置 tcp_keepalive_time，如果连接还没有建立成功，则这个值根本没有设置。</p>

<p>如果要设置后面两个数值的话，需要自己实现, 示例代码如下：</p>

<pre><code>//
// 设置 keepalive 相关的2个参数
// probes: 对应内核 tcp_keepalive_probes, 发送多少次keepalive报文还未收到回应时, close该连接
// intvl:  对应内核 tcp_keepalive_intvl, 发送keepalive报文的间隔时间
// idle:   对应内核 tcp_keepalive_time
int set_keep_alive(const uv_handle_t* handle, int probes, int intvl, int idle) {
    int ret;
    uv_os_fd_t fd;

    ret = uv_fileno(handle, &amp;fd);
    if (ret &lt; 0) {
        return ret;
    }

    if (idle &gt; 0) {
        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, sizeof(idle)))
            return -1;
    }
    // 设置 tcp_keepalive_intvl
    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL,
                (const void *) &amp;intvl, sizeof(int)) &lt; 0 ) {
        return -1;
    }

    // 设置 tcp_keepalive_probes
    if ( setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT,
                (const void *) &amp;probes, sizeof(int)) &lt; 0) {
        return -1;
    }

    return 0;
}
</code></pre>

<p>这个函数只能在连接建立成功后调用，因为只有连接建立成功才有fd，即uv_fileno才会返回成功。</p>

        </div>
      </div>
    </div>
    <div class="footer">
  
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
  
</div>

  </div>
  <script src="http://guotie.github.io/js/slim.js"></script>
  

</body>

</html>